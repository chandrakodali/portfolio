<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Terraform at Scale: Module Design Patterns | Chandra Koushik Kodali</title>
  <meta name="description"
    content="Learn how to design reusable Terraform modules, implement state management strategies, and build scalable infrastructure-as-code for enterprise environments.">
  <meta name="author" content="Chandra Koushik Kodali">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      /* Dark Theme (Default) */
      --bg-primary: #030014;
      --bg-gradient-start: #030014;
      --bg-gradient-end: #0a0a1f;
      --text-primary: #e5e7eb;
      --text-secondary: #9ca3af;
      --text-muted: #6b7280;
      --accent: #10b981;
      /* Emerald/Green for Terraform */
      --accent-hover: #34d399;
      --border: rgba(255, 255, 255, 0.1);
      --card-bg: rgba(255, 255, 255, 0.03);
      --code-bg: #0d1117;
      --heading-gradient-start: #fff;
      --heading-gradient-end: #6ee7b7;
      --heading-color: #fff;
      --table-header-bg: rgba(255, 255, 255, 0.05);
    }

    .light {
      /* Light Theme */
      --bg-primary: #ffffff;
      --bg-gradient-start: #ffffff;
      --bg-gradient-end: #f9fafb;
      --text-primary: #1f2937;
      --text-secondary: #4b5563;
      --text-muted: #6b7280;
      --accent: #059669;
      --accent-hover: #047857;
      --border: #e5e7eb;
      --card-bg: #f3f4f6;
      --code-bg: #1f2937;
      --heading-gradient-start: #111827;
      --heading-gradient-end: #047857;
      --heading-color: #111827;
      --table-header-bg: #f3f4f6;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background: var(--bg-primary);
      background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
      color: var(--text-primary);
      line-height: 1.8;
      min-height: 100vh;
      transition: background 0.3s, color 0.3s;
    }

    .container {
      max-width: 800px;
      margin: 0 auto;
      padding: 60px 24px;
      position: relative;
    }

    .nav-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 40px;
    }

    .theme-toggle {
      background: var(--card-bg);
      border: 1px solid var(--border);
      color: var(--text-secondary);
      cursor: pointer;
      padding: 8px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }

    .theme-toggle:hover {
      color: var(--text-primary);
      border-color: var(--accent);
    }

    .back-link {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      color: var(--accent);
      text-decoration: none;
      font-size: 14px;
      transition: color 0.2s;
    }

    .back-link:hover {
      color: var(--accent-hover);
    }

    .tag {
      display: inline-block;
      padding: 4px 12px;
      background: rgba(16, 185, 129, 0.15);
      border: 1px solid rgba(16, 185, 129, 0.3);
      border-radius: 9999px;
      color: var(--accent);
      font-size: 12px;
      font-weight: 500;
      margin-bottom: 16px;
    }

    h1 {
      font-size: 2.5rem;
      font-weight: 700;
      background: linear-gradient(to right, var(--heading-gradient-start), var(--heading-gradient-end));
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 16px;
      line-height: 1.2;
      color: var(--heading-color);
    }

    .meta {
      color: var(--text-muted);
      font-size: 14px;
      margin-bottom: 40px;
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
    }

    h2 {
      font-size: 1.5rem;
      color: var(--heading-color);
      margin: 48px 0 16px;
      padding-bottom: 8px;
      border-bottom: 1px solid var(--border);
    }

    h3 {
      font-size: 1.25rem;
      color: var(--text-primary);
      margin: 32px 0 12px;
    }

    h4 {
      font-size: 1.1rem;
      color: var(--text-secondary);
      margin: 24px 0 10px;
    }

    p {
      margin-bottom: 20px;
      color: var(--text-secondary);
    }

    ul,
    ol {
      margin: 0 0 20px 24px;
      color: var(--text-secondary);
    }

    li {
      margin-bottom: 8px;
    }

    .code-block {
      background: #0d1117;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 20px;
      margin: 20px 0;
      overflow-x: auto;
      font-family: 'Fira Code', monospace;
      font-size: 14px;
      color: #c9d1d9;
    }

    .code-block code {
      white-space: pre;
    }

    .highlight {
      background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(6, 182, 212, 0.1));
      border-left: 3px solid var(--accent);
      padding: 16px 20px;
      margin: 24px 0;
      border-radius: 0 12px 12px 0;
    }

    .warning {
      background: linear-gradient(135deg, rgba(245, 158, 11, 0.1), rgba(239, 68, 68, 0.1));
      border-left: 3px solid #f59e0b;
      padding: 16px 20px;
      margin: 24px 0;
      border-radius: 0 12px 12px 0;
    }

    .key-point {
      background: rgba(6, 182, 212, 0.1);
      border: 1px solid rgba(6, 182, 212, 0.3);
      border-radius: 12px;
      padding: 20px;
      margin: 24px 0;
    }

    .key-point h4 {
      color: #06b6d4;
      margin-bottom: 8px;
      font-size: 14px;
      margin-top: 0;
    }

    .edge-case {
      background: rgba(239, 68, 68, 0.1);
      border: 1px solid rgba(239, 68, 68, 0.3);
      border-radius: 12px;
      padding: 20px;
      margin: 24px 0;
    }

    .edge-case h4 {
      color: #ef4444;
      margin-bottom: 8px;
      font-size: 14px;
      margin-top: 0;
    }

    strong {
      color: var(--heading-color);
    }

    .toc {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 24px;
      margin: 32px 0;
    }

    .toc h3 {
      margin-top: 0;
      margin-bottom: 16px;
      color: var(--heading-color);
    }

    .toc ul {
      margin: 0;
      list-style: none;
      padding-left: 0;
    }

    .toc li {
      margin-bottom: 8px;
    }

    .toc a {
      color: var(--accent);
      text-decoration: none;
    }

    .toc a:hover {
      text-decoration: underline;
    }

    .diagram {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 32px;
      margin: 32px 0;
      overflow-x: auto;
    }

    .diagram-title {
      font-size: 14px;
      color: var(--text-muted);
      text-align: center;
      margin-bottom: 24px;
      font-weight: 500;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
      font-size: 14px;
    }

    th,
    td {
      padding: 12px;
      text-align: left;
      border-bottom: 1px solid var(--border);
    }

    th {
      color: var(--heading-color);
      background: var(--table-header-bg);
    }

    td {
      color: var(--text-secondary);
    }

    .tree {
      font-family: 'Fira Code', monospace;
      font-size: 13px;
      line-height: 1.6;
      color: var(--text-secondary);
      background: #0d1117;
      padding: 20px;
      border-radius: 12px;
      margin: 20px 0;
      overflow-x: auto;
    }

    .tree .folder {
      color: var(--accent);
    }

    .tree .file {
      color: var(--text-secondary);
    }

    .footer {
      margin-top: 60px;
      padding-top: 40px;
      border-top: 1px solid var(--border);
      text-align: center;
      color: var(--text-muted);
      font-size: 14px;
    }

    .cta {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      background: linear-gradient(135deg, var(--accent), #06b6d4);
      color: #fff;
      padding: 12px 24px;
      border-radius: 12px;
      text-decoration: none;
      font-weight: 500;
      margin-top: 20px;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .cta:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 40px rgba(16, 185, 129, 0.3);
    }
  </style>
  <link rel="stylesheet" href="article-interactive.css">
  <script>
    // Check for theme preference
    const savedTheme = localStorage.getItem('theme');
    if (savedTheme === 'light') {
      document.documentElement.classList.add('light');
    }

    function toggleTheme() {
      const isLight = document.documentElement.classList.toggle('light');
      localStorage.setItem('theme', isLight ? 'light' : 'dark');
    }
  </script>
</head>

<body>
  <article class="container">
    <div class="nav-header">
      <a href="/portfolio/#articles" class="back-link">‚Üê Back to Portfolio</a>
      <button class="theme-toggle" onclick="toggleTheme()" title="Toggle Theme">
        <!-- Sun Icon -->
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
          stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="12" cy="12" r="5"></circle>
          <line x1="12" y1="1" x2="12" y2="3"></line>
          <line x1="12" y1="21" x2="12" y2="23"></line>
          <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
          <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
          <line x1="1" y1="12" x2="3" y2="12"></line>
          <line x1="21" y1="12" x2="23" y2="12"></line>
          <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
          <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
        </svg>
      </button>
    </div>

    <span class="tag">Infrastructure</span>
    <h1>Terraform at Scale: Module Design Patterns</h1>

    <div class="meta">
      <span>By Chandra Koushik Kodali</span>
      <span>‚Ä¢</span>
      <span>24 min read</span>
      <span>‚Ä¢</span>
      <span>January 2026</span>
    </div>

    <p>
      Infrastructure as Code (IaC) with Terraform has become the de facto standard for managing cloud
      infrastructure. However, as organizations scale, the challenges of maintaining Terraform code across
      hundreds of projects and dozens of teams become significant. In this comprehensive guide, I'll share proven
      patterns and practices for designing reusable Terraform modules that scale across enterprise environments.
    </p>

    <a href="https://github.com/chandrakodali/terraform-aws-eks-platform" target="_blank" class="github-link">
      <svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg">
        <path fill-rule="evenodd"
          d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z" />
      </svg>
      <span>
        <span class="repo-name">chandrakodali/terraform-aws-eks-platform</span>
        <span class="repo-desc">Live example: VPC, EKS, IAM, Kubernetes modules with multi-environment setup</span>
      </span>
    </a>

    <div class="real-world">
      <h4>From My Experience</h4>
      <p>
        The patterns in this article come from building and maintaining the
        <a href="https://github.com/chandrakodali/terraform-aws-eks-platform"
          target="_blank">terraform-aws-eks-platform</a>
        project, which provisions complete EKS infrastructure including VPC networking, IAM roles with 3-tier access
        (Admin/Developer/ReadOnly), Kubernetes RBAC, EFS storage, and bastion hosts. This modular approach reduced
        our <strong>infrastructure provisioning time from 4 hours to 15 minutes</strong> and enabled non-infrastructure
        engineers to safely deploy environments using simple variable overrides.
      </p>
    </div>

    <div class="toc">
      <h3>Table of Contents</h3>
      <ul>
        <li><a href="#module-principles">1. Module Design Principles</a></li>
        <li><a href="#architecture-decisions">2. Architecture Decision Records</a></li>
        <li><a href="#module-structure">3. Module Structure and Organization</a></li>
        <li><a href="#composition-patterns">4. Composition Patterns</a></li>
        <li><a href="#state-management">5. State Management Strategies</a></li>
        <li><a href="#day2-operations">6. Day 2 Operations at Scale</a></li>
        <li><a href="#testing">7. Testing and Validation</a></li>
        <li><a href="#cicd">8. CI/CD Pipeline Integration</a></li>
        <li><a href="#versioning">9. Versioning and Release Management</a></li>
        <li><a href="#security">10. Security Best Practices</a></li>
        <li><a href="#cost-optimization">11. Cost Optimization (FinOps)</a></li>
        <li><a href="#anti-patterns">12. Anti-Patterns to Avoid</a></li>
        <li><a href="#multi-account">13. Multi-Account and Multi-Region</a></li>
        <li><a href="#edge-cases">14. Edge Cases and Troubleshooting</a></li>
        <li><a href="#migration">15. Migration and Upgrade Strategies</a></li>
      </ul>
    </div>

    <h2 id="module-principles">1. Module Design Principles</h2>

    <p>Good Terraform modules follow several key principles that make them reusable, maintainable, and safe to use.
    </p>

    <h3>Single Responsibility</h3>
    <p>
      Each module should do one thing well. A VPC module creates networking resources. An EKS module creates
      Kubernetes clusters. Don't combine unrelated resources just because they're often used together.
    </p>

    <h3>Sensible Defaults with Overridability</h3>
    <p>
      Provide reasonable defaults for all optional variables while allowing users to override everything. This
      balances ease of use with flexibility.
    </p>

    <div class="code-block"><code>variable "instance_type" {
  description = "EC2 instance type"
  type        = string
  default     = "t3.medium"  # Sensible default
}

variable "enable_monitoring" {
  description = "Enable detailed CloudWatch monitoring"
  type        = bool
  default     = true  # Safe default
}

variable "tags" {
  description = "Additional tags to apply to resources"
  type        = map(string)
  default     = {}  # Allow complete customization
}</code></div>

    <h3>Explicit Over Implicit</h3>
    <p>
      Make dependencies and requirements explicit. Don't rely on implicit behavior or provider defaults that might
      change.
    </p>

    <div class="code-block"><code># Bad: Implicit dependency on default VPC
resource "aws_instance" "example" {
  ami           = var.ami_id
  instance_type = var.instance_type
}

# Good: Explicit subnet requirement
resource "aws_instance" "example" {
  ami           = var.ami_id
  instance_type = var.instance_type
  subnet_id     = var.subnet_id  # Explicit
  
  vpc_security_group_ids = var.security_group_ids  # Explicit
}</code></div>

    <h3>Idempotency and Predictability</h3>
    <p>
      Modules should produce the same result when applied multiple times. Avoid resources with random generation,
      timestamps, or external data sources that change unpredictably.
    </p>

    <div class="highlight">
      <strong>Golden Rule:</strong> A user should be able to read your module's variables.tf and outputs.tf and
      understand exactly what the module does without reading the implementation.
    </div>

    <h2 id="architecture-decisions">2. Architecture Decision Records</h2>

    <p>
      Before diving into patterns, let's document why we chose Terraform and specific architectural
      decisions. These ADRs explain the trade-offs that shaped our approach.
    </p>

    <h3>ADR 1: Why Terraform Over CDK/Pulumi?</h3>

    <table>
      <thead>
        <tr>
          <th>Criteria</th>
          <th>Terraform (HCL)</th>
          <th>AWS CDK</th>
          <th>Pulumi</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>Language</strong></td>
          <td>HCL (domain-specific)</td>
          <td>TypeScript/Python/Java</td>
          <td>TypeScript/Python/Go</td>
        </tr>
        <tr>
          <td><strong>State management</strong></td>
          <td>Mature, battle-tested</td>
          <td>CloudFormation stacks</td>
          <td>Pulumi Cloud or S3</td>
        </tr>
        <tr>
          <td><strong>Multi-cloud</strong></td>
          <td>‚úÖ First-class support</td>
          <td>‚ùå AWS only</td>
          <td>‚úÖ Good support</td>
        </tr>
        <tr>
          <td><strong>Provider ecosystem</strong></td>
          <td>4000+ providers</td>
          <td>AWS + limited L3</td>
          <td>Good, growing</td>
        </tr>
        <tr>
          <td><strong>Debugging</strong></td>
          <td>Declarative (plan-driven)</td>
          <td>Imperative (stack traces)</td>
          <td>Imperative</td>
        </tr>
        <tr>
          <td><strong>Team adoption</strong></td>
          <td>Lower barrier (HCL simple)</td>
          <td>Requires dev skills</td>
          <td>Requires dev skills</td>
        </tr>
      </tbody>
    </table>

    <div class="lesson-learned">
      <h4>Our Decision</h4>
      <p>
        We chose Terraform because: (1) our team includes ops engineers who aren't software developers,
        (2) we deploy across AWS, Azure, and 15+ SaaS providers, and (3) when something breaks at 2 AM,
        <code>terraform plan</code> output is easier to reason about than a TypeScript stack trace.
        For pure-AWS shops with strong dev teams, CDK is a valid choice.
      </p>
    </div>

    <h3>ADR 2: Monorepo vs. Polyrepo for Modules?</h3>

    <table>
      <thead>
        <tr>
          <th>Aspect</th>
          <th>Monorepo</th>
          <th>Polyrepo</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>Versioning</strong></td>
          <td>Atomic cross-module changes</td>
          <td>Independent semver per module</td>
        </tr>
        <tr>
          <td><strong>Terraform Registry</strong></td>
          <td>‚ùå Can't publish (one repo = one module)</td>
          <td>‚úÖ Each module gets registry entry</td>
        </tr>
        <tr>
          <td><strong>CI complexity</strong></td>
          <td>Single pipeline, path filtering</td>
          <td>Multiple pipelines</td>
        </tr>
        <tr>
          <td><strong>Discoverability</strong></td>
          <td>All modules in one place</td>
          <td>Need catalog/docs site</td>
        </tr>
        <tr>
          <td><strong>Access control</strong></td>
          <td>Same permissions for all modules</td>
          <td>Per-module permissions possible</td>
        </tr>
      </tbody>
    </table>

    <div class="real-world">
      <h4>From Our EKS Platform</h4>
      <p>
        In <a href="https://github.com/chandrakodali/terraform-aws-eks-platform"
          target="_blank">terraform-aws-eks-platform</a>,
        we use a monorepo with <code>module/</code> subdirectories because: (1) VPC, EKS, and IAM modules
        are tightly coupled and change together, (2) we don't publish to the public registry, and
        (3) testing cross-module integrations is simpler. For enterprise with 50+ modules consumed by
        different teams, polyrepo makes more sense.
      </p>
    </div>

    <h3>ADR 3: Remote State (S3) vs. Terraform Cloud?</h3>

    <table>
      <thead>
        <tr>
          <th>Factor</th>
          <th>S3 + DynamoDB</th>
          <th>Terraform Cloud</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>Cost (100 workspaces)</strong></td>
          <td>~$20/month</td>
          <td>~$700-2000/month</td>
        </tr>
        <tr>
          <td><strong>Setup complexity</strong></td>
          <td>DIY (bucket, table, policies)</td>
          <td>Managed SaaS</td>
        </tr>
        <tr>
          <td><strong>UI/collaboration</strong></td>
          <td>None built-in</td>
          <td>Excellent</td>
        </tr>
        <tr>
          <td><strong>Policy as Code</strong></td>
          <td>OPA/Conftest (DIY)</td>
          <td>Sentinel (built-in)</td>
        </tr>
        <tr>
          <td><strong>Private runners</strong></td>
          <td>Your CI/CD</td>
          <td>TFC agents or managed</td>
        </tr>
        <tr>
          <td><strong>Data residency</strong></td>
          <td>Your AWS region</td>
          <td>HashiCorp regions</td>
        </tr>
      </tbody>
    </table>

    <div class="lesson-learned">
      <h4>Cost Analysis Drove Our Decision</h4>
      <p>
        At 150+ workspaces, Terraform Cloud would cost us $18K+/year. We built a S3 backend with
        DynamoDB locking for $240/year. The trade-off: we built our own run history tracking and
        approval workflows in GitHub Actions. If your team is small and values collaboration UI,
        TFC's free tier (5 users) is excellent.
      </p>
    </div>

    <h2 id="module-structure">3. Module Structure and Organization</h2>

    <div class="diagram">
      <div class="diagram-title">Figure 1: Terraform Module Composition</div>
      <img src="images/terraform-structure.png" alt="Terraform Module Structure Diagram"
        style="width:100%; border-radius: 8px;">
    </div>

    <h3>Standard Module Layout</h3>
    <p>
      A consistent directory structure is crucial for discoverability. We recommend the following standard layout
      that separates implementation, interface, and examples:
    </p>

    <div class="tree"><span class="folder">terraform-aws-eks/</span>
      ‚îú‚îÄ‚îÄ <span class="file">README.md</span> # Documentation with examples
      ‚îú‚îÄ‚îÄ <span class="file">main.tf</span> # Primary resource definitions
      ‚îú‚îÄ‚îÄ <span class="file">variables.tf</span> # Input variable definitions
      ‚îú‚îÄ‚îÄ <span class="file">outputs.tf</span> # Output value definitions
      ‚îú‚îÄ‚îÄ <span class="file">versions.tf</span> # Provider and Terraform version constraints
      ‚îú‚îÄ‚îÄ <span class="file">locals.tf</span> # Local value definitions
      ‚îú‚îÄ‚îÄ <span class="file">data.tf</span> # Data source definitions
      ‚îú‚îÄ‚îÄ <span class="folder">modules/</span> # Nested submodules
      ‚îÇ ‚îú‚îÄ‚îÄ <span class="folder">node-group/</span>
      ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ <span class="file">main.tf</span>
      ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ <span class="file">variables.tf</span>
      ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ <span class="file">outputs.tf</span>
      ‚îÇ ‚îî‚îÄ‚îÄ <span class="folder">addons/</span>
      ‚îÇ ‚îú‚îÄ‚îÄ <span class="file">main.tf</span>
      ‚îÇ ‚îú‚îÄ‚îÄ <span class="file">variables.tf</span>
      ‚îÇ ‚îî‚îÄ‚îÄ <span class="file">outputs.tf</span>
      ‚îú‚îÄ‚îÄ <span class="folder">examples/</span> # Usage examples
      ‚îÇ ‚îú‚îÄ‚îÄ <span class="folder">complete/</span>
      ‚îÇ ‚îú‚îÄ‚îÄ <span class="folder">minimal/</span>
      ‚îÇ ‚îî‚îÄ‚îÄ <span class="folder">with-fargate/</span>
      ‚îî‚îÄ‚îÄ <span class="folder">test/</span> # Automated tests
      ‚îî‚îÄ‚îÄ <span class="file">eks_test.go</span></div>

    <div class="lesson-learned">
      <h4>Lesson Learned: Module Separation Saved Us During Migration</h4>
      <p>
        In my <a href="https://github.com/chandrakodali/terraform-aws-eks-platform" target="_blank">EKS platform</a>,
        I separated modules by AWS service: <code>module/vpc</code>, <code>module/eks</code>, <code>module/iam</code>,
        <code>module/iam_users</code>, <code>module/kubernetes</code>, and <code>module/ec2</code>. This separation
        paid off when we needed to upgrade our EKS version ‚Äî we could update just the EKS module without touching
        VPC or IAM. The pattern: <strong>if two resources have different lifecycle or ownership, they belong in
          different modules</strong>.
      </p>
    </div>

    <div class="diagram">
      <div class="diagram-title">Figure 2: Module Dependency Graph</div>
      <svg viewBox="0 0 700 350" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <linearGradient id="vpcGrad" x1="0%" y1="0%" x2="100%" y2="0%">
            <stop offset="0%" style="stop-color:#06b6d4;stop-opacity:0.3" />
            <stop offset="100%" style="stop-color:#0ea5e9;stop-opacity:0.3" />
          </linearGradient>
          <linearGradient id="iamGrad" x1="0%" y1="0%" x2="100%" y2="0%">
            <stop offset="0%" style="stop-color:#f59e0b;stop-opacity:0.3" />
            <stop offset="100%" style="stop-color:#eab308;stop-opacity:0.3" />
          </linearGradient>
          <linearGradient id="eksGrad" x1="0%" y1="0%" x2="100%" y2="0%">
            <stop offset="0%" style="stop-color:#10b981;stop-opacity:0.3" />
            <stop offset="100%" style="stop-color:#22c55e;stop-opacity:0.3" />
          </linearGradient>
          <linearGradient id="k8sGrad" x1="0%" y1="0%" x2="100%" y2="0%">
            <stop offset="0%" style="stop-color:#8b5cf6;stop-opacity:0.3" />
            <stop offset="100%" style="stop-color:#a855f7;stop-opacity:0.3" />
          </linearGradient>
        </defs>

        <!-- Root Module (Environment) -->
        <rect x="275" y="20" width="150" height="60" rx="8" fill="#1e1e2e" stroke="#6366f1" stroke-width="2" />
        <text x="350" y="45" fill="#a5b4fc" font-size="11" text-anchor="middle">environment/</text>
        <text x="350" y="62" fill="#818cf8" font-size="12" font-weight="600" text-anchor="middle">main.tf</text>

        <!-- Layer 1: VPC & IAM (no inter-dependencies) -->
        <rect x="50" y="120" width="140" height="60" rx="8" fill="url(#vpcGrad)" stroke="#06b6d4" stroke-width="2" />
        <text x="120" y="145" fill="#06b6d4" font-size="12" font-weight="600" text-anchor="middle">module/vpc</text>
        <text x="120" y="162" fill="#9ca3af" font-size="10" text-anchor="middle">VPC, Subnets, NAT</text>

        <rect x="280" y="120" width="140" height="60" rx="8" fill="url(#iamGrad)" stroke="#f59e0b" stroke-width="2" />
        <text x="350" y="145" fill="#f59e0b" font-size="12" font-weight="600" text-anchor="middle">module/iam</text>
        <text x="350" y="162" fill="#9ca3af" font-size="10" text-anchor="middle">Roles, OIDC, Policies</text>

        <rect x="510" y="120" width="140" height="60" rx="8" fill="url(#iamGrad)" stroke="#f59e0b" stroke-width="2" />
        <text x="580" y="145" fill="#f59e0b" font-size="12" font-weight="600"
          text-anchor="middle">module/iam_users</text>
        <text x="580" y="162" fill="#9ca3af" font-size="10" text-anchor="middle">Users, Groups</text>

        <!-- Layer 2: EKS (depends on VPC & IAM) -->
        <rect x="165" y="220" width="140" height="60" rx="8" fill="url(#eksGrad)" stroke="#10b981" stroke-width="2" />
        <text x="235" y="245" fill="#10b981" font-size="12" font-weight="600" text-anchor="middle">module/eks</text>
        <text x="235" y="262" fill="#9ca3af" font-size="10" text-anchor="middle">Cluster, Node Groups</text>

        <rect x="395" y="220" width="140" height="60" rx="8" fill="#1e1e2e" stroke="#64748b" stroke-width="2" />
        <text x="465" y="245" fill="#94a3b8" font-size="12" font-weight="600" text-anchor="middle">module/ec2</text>
        <text x="465" y="262" fill="#9ca3af" font-size="10" text-anchor="middle">Bastion Host</text>

        <!-- Layer 3: Kubernetes (depends on EKS) -->
        <rect x="275" y="310" width="150" height="60" rx="8" fill="url(#k8sGrad)" stroke="#8b5cf6" stroke-width="2" />
        <text x="350" y="335" fill="#8b5cf6" font-size="12" font-weight="600"
          text-anchor="middle">module/kubernetes</text>
        <text x="350" y="352" fill="#9ca3af" font-size="10" text-anchor="middle">RBAC, Namespaces</text>

        <!-- Arrows: Root to Layer 1 -->
        <path d="M300 80 L140 115" stroke="#6b7280" stroke-width="1.5" />
        <path d="M350 80 L350 115" stroke="#6b7280" stroke-width="1.5" />
        <path d="M400 80 L560 115" stroke="#6b7280" stroke-width="1.5" />

        <!-- Arrows: Layer 1 to Layer 2 -->
        <path d="M140 180 L210 215" stroke="#6b7280" stroke-width="1.5" />
        <path d="M350 180 L260 215" stroke="#6b7280" stroke-width="1.5" />
        <path d="M120 180 L440 215" stroke="#6b7280" stroke-width="1.5" stroke-dasharray="4" />

        <!-- Arrows: Layer 2 to Layer 3 -->
        <path d="M260 280 L325 305" stroke="#6b7280" stroke-width="1.5" />
        <path d="M350 180 L350 305" stroke="#6b7280" stroke-width="1.5" stroke-dasharray="4" />
      </svg>
    </div>

    <h3>Variables Best Practices</h3>
    <p>
      Use robust validation rules and explicit types to fail fast. Here is an example of a well-structured
      <code>variables.tf</code> file:
    </p>

    <div class="code-block"><code># variables.tf
variable "cluster_name" {
  description = "Name of the EKS cluster. Must be unique within the AWS account."
  type        = string

  validation {
    condition     = can(regex("^[a-zA-Z][a-zA-Z0-9-]*$", var.cluster_name))
    error_message = "Cluster name must start with a letter and contain only alphanumeric characters and hyphens."
  }
}

variable "cluster_version" {
  description = "Kubernetes version for the EKS cluster"
  type        = string
  default     = "1.28"

  validation {
    condition     = contains(["1.27", "1.28", "1.29"], var.cluster_version)
    error_message = "Cluster version must be one of: 1.27, 1.28, 1.29."
  }
}

variable "node_groups" {
  description = "Map of node group configurations"
  type = map(object({
    instance_types = list(string)
    min_size       = number
    max_size       = number
    desired_size   = number
    disk_size      = optional(number, 50)
    labels         = optional(map(string), {})
    taints = optional(list(object({
      key    = string
      value  = string
      effect = string
    })), [])
  }))
  default = {}
}</code></div>

    <h3>Outputs Design</h3>
    <p>
      Outputs are the API of your module. Return detailed information that consumers might need, and mark
      sensitive
      data appropriately:
    </p>

    <div class="code-block"><code># outputs.tf
output "cluster_endpoint" {
  description = "Endpoint URL for the EKS cluster API server"
  value       = aws_eks_cluster.this.endpoint
}

output "cluster_certificate_authority_data" {
  description = "Base64 encoded certificate data for cluster authentication"
  value       = aws_eks_cluster.this.certificate_authority[0].data
  sensitive   = true
}

output "cluster_security_group_id" {
  description = "Security group ID attached to the EKS cluster"
  value       = aws_eks_cluster.this.vpc_config[0].cluster_security_group_id
}

# Provide a complete kubectl config for convenience
output "kubectl_config" {
  description = "kubectl configuration for connecting to the cluster"
  value = {
    host                   = aws_eks_cluster.this.endpoint
    cluster_ca_certificate = base64decode(aws_eks_cluster.this.certificate_authority[0].data)
    token                  = data.aws_eks_cluster_auth.this.token
  }
  sensitive = true
}</code></div>

    <h2 id="composition-patterns">3. Composition Patterns</h2>

    <h3>Module Composition</h3>
    <p>
      Complex infrastructure should be composed of smaller, focused modules. Here's how to structure a complete
      platform:
    </p>

    <div class="code-block"><code># Root module that composes other modules
module "vpc" {
  source  = "terraform-aws-modules/vpc/aws"
  version = "5.0.0"

  name = "${var.environment}-vpc"
  cidr = var.vpc_cidr

  azs             = var.availability_zones
  private_subnets = var.private_subnet_cidrs
  public_subnets  = var.public_subnet_cidrs

  enable_nat_gateway = true
  single_nat_gateway = var.environment != "prod"

  tags = local.common_tags
}

module "eks" {
  source = "./modules/eks"

  cluster_name    = "${var.environment}-cluster"
  cluster_version = var.kubernetes_version
  
  vpc_id          = module.vpc.vpc_id
  subnet_ids      = module.vpc.private_subnets

  node_groups = var.node_groups

  tags = local.common_tags
}

module "rds" {
  source = "./modules/rds"

  identifier     = "${var.environment}-db"
  engine_version = var.postgres_version

  vpc_id             = module.vpc.vpc_id
  subnet_ids         = module.vpc.database_subnets
  security_group_ids = [module.eks.node_security_group_id]

  tags = local.common_tags
}</code></div>

    <h3>The Factory Pattern</h3>
    <p>
      For standardized deployments across many environments, use a factory pattern:
    </p>

    <div class="code-block"><code># environments/factory/main.tf
variable "environments" {
  type = map(object({
    vpc_cidr          = string
    instance_type     = string
    node_count        = number
    enable_monitoring = bool
  }))
}

module "environment" {
  source   = "../modules/environment"
  for_each = var.environments

  environment       = each.key
  vpc_cidr          = each.value.vpc_cidr
  instance_type     = each.value.instance_type
  node_count        = each.value.node_count
  enable_monitoring = each.value.enable_monitoring
}

# environments/factory/terraform.tfvars
environments = {
  dev = {
    vpc_cidr          = "10.0.0.0/16"
    instance_type     = "t3.medium"
    node_count        = 2
    enable_monitoring = false
  }
  staging = {
    vpc_cidr          = "10.1.0.0/16"
    instance_type     = "t3.large"
    node_count        = 3
    enable_monitoring = true
  }
  prod = {
    vpc_cidr          = "10.2.0.0/16"
    instance_type     = "m5.xlarge"
    node_count        = 5
    enable_monitoring = true
  }
}</code></div>

    <h2 id="state-management">4. State Management Strategies</h2>

    <h3>Remote State Backend</h3>
    <p>
      Never store state locally. Use a remote backend like S3 with DynamoDB locking to ensure team collaboration
      safety:
    </p>

    <div class="code-block"><code># backend.tf
terraform {
  backend "s3" {
    bucket         = "company-terraform-state"
    key            = "environments/prod/eks/terraform.tfstate"
    region         = "us-east-1"
    encrypt        = true
    dynamodb_table = "terraform-state-lock"
    
    # Use assume_role for cross-account access
    assume_role {
      role_arn = "arn:aws:iam::123456789012:role/TerraformStateAccess"
    }
  }
}</code></div>

    <h3>State Isolation Strategies</h3>

    <table>
      <tr>
        <th>Strategy</th>
        <th>When to Use</th>
        <th>Tradeoffs</th>
      </tr>
      <tr>
        <td>Per-environment</td>
        <td>Complete isolation between dev/staging/prod</td>
        <td>Cannot share resources easily</td>
      </tr>
      <tr>
        <td>Per-component</td>
        <td>Independent lifecycle for VPC, EKS, apps</td>
        <td>Requires data source lookups</td>
      </tr>
      <tr>
        <td>Monolithic</td>
        <td>Small projects, tight coupling</td>
        <td>Blast radius, slow plans</td>
      </tr>
    </table>

    <h3>Cross-State References</h3>
    <p>
      Use the <code>terraform_remote_state</code> data source to read outputs from other stacks, such as reading
      VPC
      details into your EKS stack:
    </p>

    <div class="code-block"><code># In the EKS module, reference VPC state
data "terraform_remote_state" "vpc" {
  backend = "s3"
  config = {
    bucket = "company-terraform-state"
    key    = "environments/${var.environment}/vpc/terraform.tfstate"
    region = "us-east-1"
  }
}

# Use outputs from VPC state
module "eks" {
  source = "./modules/eks"

  vpc_id     = data.terraform_remote_state.vpc.outputs.vpc_id
  subnet_ids = data.terraform_remote_state.vpc.outputs.private_subnets
}</code></div>

    <div class="warning">
      <strong>‚ö†Ô∏è Warning:</strong> Cross-state references create implicit dependencies. Document these
      relationships clearly and consider using explicit data sources instead for better discoverability.
    </div>

    <h2 id="day2-operations">6. Day 2 Operations at Scale</h2>

    <p>
      Setup is day one. The real work begins when you're managing 500+ resources across 50+ workspaces.
      This section covers the operational patterns that tutorials never mention.
    </p>

    <h3>State Drift Detection and Remediation</h3>

    <p>
      State drift happens when resources are modified outside Terraform (console clicks, CLI, other tools).
      Here's how we detect and remediate:
    </p>

    <h4>Automated Drift Detection Pipeline</h4>

    <div class="code-block"><code># .github/workflows/drift-detection.yml
name: Terraform Drift Detection
on:
  schedule:
    - cron: '0 6 * * *'  # Daily at 6 AM

jobs:
  detect-drift:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        environment: [dev, staging, prod]
    steps:
      - uses: actions/checkout@v4
      
      - name: Terraform Plan (Drift Check)
        run: |
          cd environments/${{ matrix.environment }}
          terraform init -backend-config="env/${{ matrix.environment }}.hcl"
          terraform plan -detailed-exitcode -out=plan.out 2>&1 | tee plan.txt
          EXIT_CODE=$?
          if [ $EXIT_CODE -eq 2 ]; then
            echo "DRIFT_DETECTED=true" >> $GITHUB_ENV
          fi
      
      - name: Alert on Drift
        if: env.DRIFT_DETECTED == 'true'
        uses: slackapi/slack-github-action@v1
        with:
          payload: |
            {"text": "üö® Drift detected in ${{ matrix.environment }}! Review plan output."}</code></div>

    <div class="lesson-learned">
      <h4>Drift Remediation Strategies</h4>
      <p>
        Not all drift should be auto-remediated. We categorize drift and handle it differently:
      </p>
      <ul>
        <li><strong>Harmless drift</strong> (tags added by AWS): Add to <code>lifecycle { ignore_changes }</code></li>
        <li><strong>Expected drift</strong> (autoscaling): Use data sources to read current state</li>
        <li><strong>Unauthorized drift</strong> (console changes): Alert + automatic terraform apply</li>
        <li><strong>Critical drift</strong> (security groups): Alert + require manual approval</li>
      </ul>
    </div>

    <h3>Breaking Module Changes (v1 ‚Üí v2 Migration)</h3>

    <p>
      Module upgrades with breaking changes are the #1 cause of Terraform outages. Here's how we handle them:
    </p>

    <h4>Using Moved Blocks (Terraform 1.1+)</h4>

    <div class="code-block"><code># When renaming resources within a module
moved {
  from = aws_iam_role.eks_cluster
  to   = aws_iam_role.cluster
}

moved {
  from = module.eks_nodes
  to   = module.node_groups
}

# For count ‚Üí for_each migrations
moved {
  from = aws_subnet.private[0]
  to   = aws_subnet.private["us-east-1a"]
}</code></div>

    <h4>Blue-Green Module Migration</h4>

    <div class="code-block"><code># Step 1: Deploy new module alongside old
module "eks_v1" {
  source = "./modules/eks-v1"
  # ... existing config
}

module "eks_v2" {
  source = "./modules/eks-v2"
  # ... new config (separate cluster initially)
}

# Step 2: Migrate workloads to v2 cluster
# Step 3: Remove v1 module
# Step 4: Rename v2 to primary</code></div>

    <div class="real-world">
      <h4>From My Experience</h4>
      <p>
        When we migrated our EKS module from <code>count</code> to <code>for_each</code> for node groups,
        we had a choice: force resource recreation (downtime) or use <code>moved</code> blocks. We created
        120 moved blocks to preserve every resource. The migration took <strong>0 seconds of downtime</strong>
        ‚Äî Terraform just updated the state addressing.
      </p>
    </div>

    <h3>Terraform at 10,000+ Resources</h3>

    <p>Beyond a few thousand resources, Terraform performance degrades. Here's how to scale:</p>

    <table>
      <thead>
        <tr>
          <th>Problem</th>
          <th>Symptom</th>
          <th>Solution</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>Slow refresh</strong></td>
          <td>Plan takes 10+ minutes</td>
          <td><code>-refresh=false</code> for known-clean states</td>
        </tr>
        <tr>
          <td><strong>API throttling</strong></td>
          <td>Rate limit errors</td>
          <td><code>-parallelism=5</code> (default is 10)</td>
        </tr>
        <tr>
          <td><strong>Large state files</strong></td>
          <td>State download timeouts</td>
          <td>Split into smaller state files</td>
        </tr>
        <tr>
          <td><strong>Memory exhaustion</strong></td>
          <td>OOM kills</td>
          <td>Use <code>-target</code> for large changes</td>
        </tr>
      </tbody>
    </table>

    <h4>State Splitting Strategy</h4>

    <div class="code-block"><code># Before: Monolithic state
environments/prod/
  ‚îî‚îÄ‚îÄ main.tf  # 3000 resources, 15 minute plans

# After: Split by blast radius
environments/prod/
  ‚îú‚îÄ‚îÄ networking/      # VPC, subnets, NAT (rarely changes)
  ‚îÇ   ‚îî‚îÄ‚îÄ main.tf      # 50 resources
  ‚îú‚îÄ‚îÄ compute/         # EKS, node groups
  ‚îÇ   ‚îî‚îÄ‚îÄ main.tf      # 200 resources  
  ‚îú‚îÄ‚îÄ data/            # RDS, ElastiCache
  ‚îÇ   ‚îî‚îÄ‚îÄ main.tf      # 30 resources
  ‚îî‚îÄ‚îÄ applications/    # Helm releases, K8s resources
      ‚îî‚îÄ‚îÄ main.tf      # 2700 resources, but isolated</code></div>

    <div class="lesson-learned">
      <h4>The 1000-Resource Rule</h4>
      <p>
        We learned this the hard way: <strong>never exceed 1000 resources per state file</strong>.
        Beyond that, plan times become unusable, and the blast radius of a corrupted state is too large.
        Our EKS platform uses 6 separate state files per environment, even though they could technically
        be one.
      </p>
    </div>

    <h2 id="testing">7. Testing and Validation</h2>

    <h3>Static Analysis</h3>
    <p>
      Shift testing left by running static analysis tools in your pre-commit hooks. This catches syntax errors and
      policy violations before code is even pushed:
    </p>

    <div class="code-block"><code># .pre-commit-config.yaml
repos:
  - repo: https://github.com/antonbabenko/pre-commit-terraform
    rev: v1.83.0
    hooks:
      - id: terraform_fmt
      - id: terraform_validate
      - id: terraform_tflint
        args:
          - '--args=--config=__GIT_WORKING_DIR__/.tflint.hcl'
      - id: terraform_docs
        args:
          - '--args=--config=.terraform-docs.yml'
      - id: terraform_checkov
        args:
          - '--args=--quiet --framework terraform'</code></div>

    <h3>Unit Tests with Terratest</h3>
    <p>
      For critical modules, write integration tests using Terratest (Go) to spin up real resources, validate them,
      and tear them down:
    </p>

    <div class="code-block"><code>// test/eks_test.go
package test

import (
    "testing"
    "github.com/gruntwork-io/terratest/modules/terraform"
    "github.com/stretchr/testify/assert"
)

func TestEKSModule(t *testing.T) {
    t.Parallel()

    terraformOptions := terraform.WithDefaultRetryableErrors(t, &terraform.Options{
        TerraformDir: "../examples/minimal",
        Vars: map[string]interface{}{
            "cluster_name": "test-cluster",
            "environment":  "test",
        },
    })

    defer terraform.Destroy(t, terraformOptions)
    terraform.InitAndApply(t, terraformOptions)

    // Validate outputs
    clusterEndpoint := terraform.Output(t, terraformOptions, "cluster_endpoint")
    assert.Contains(t, clusterEndpoint, "eks.amazonaws.com")

    clusterVersion := terraform.Output(t, terraformOptions, "cluster_version")
    assert.Equal(t, "1.28", clusterVersion)
}</code></div>

    <h3>Policy as Code with OPA</h3>
    <p>
      Enforce organizational standards (like required tags or encryption) using Open Policy Agent (OPA) rules:
    </p>

    <div class="code-block"><code># policies/required_tags.rego
package terraform.policies

deny[msg] {
    resource := input.planned_values.root_module.resources[_]
    required_tags := {"Environment", "Owner", "CostCenter"}
    provided_tags := {tag | resource.values.tags[tag]}
    missing := required_tags - provided_tags
    count(missing) > 0
    msg := sprintf("Resource %s is missing required tags: %v", [resource.address, missing])
}

deny[msg] {
    resource := input.planned_values.root_module.resources[_]
    resource.type == "aws_s3_bucket"
    not resource.values.versioning[0].enabled
    msg := sprintf("S3 bucket %s must have versioning enabled", [resource.address])
}</code></div>

    <h2 id="cicd">6. CI/CD Pipeline Integration</h2>

    <h3>GitHub Actions Workflow</h3>

    <div class="code-block"><code># .github/workflows/terraform.yml
name: Terraform CI/CD

on:
  pull_request:
    branches: [main]
  push:
    branches: [main]

env:
  TF_VERSION: "1.6.0"

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
      
      - name: Terraform Format Check
        run: terraform fmt -check -recursive
      
      - name: Terraform Init
        run: terraform init -backend=false
      
      - name: Terraform Validate
        run: terraform validate

  plan:
    needs: validate
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - uses: actions/checkout@v4
      
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: us-east-1
      
      - uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
      
      - name: Terraform Init
        run: terraform init
      
      - name: Terraform Plan
        id: plan
        run: terraform plan -out=tfplan -no-color
        continue-on-error: true
      
      - name: Comment Plan on PR
        uses: actions/github-script@v7
        with:
          script: |
            const plan = `${{ steps.plan.outputs.stdout }}`
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: '## Terraform Plan\n\`\`\`hcl\n' + plan + '\n\`\`\`'
            })

  apply:
    needs: validate
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    environment: production
    steps:
      - uses: actions/checkout@v4
      
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: us-east-1
      
      - uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
      
      - name: Terraform Init
        run: terraform init
      
      - name: Terraform Apply
        run: terraform apply -auto-approve</code></div>

    <h2 id="versioning">7. Versioning and Release Management</h2>

    <h3>Semantic Versioning for Modules</h3>

    <div class="code-block"><code># versions.tf
terraform {
  required_version = ">= 1.5.0"  # Minimum Terraform version

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = ">= 5.0, < 6.0"  # Compatible provider versions
    }
  }
}

# In calling code, pin module versions
module "eks" {
  source  = "git::https://github.com/company/terraform-aws-eks.git?ref=v3.2.1"
  # OR using registry
  source  = "company/eks/aws"
  version = "~> 3.2"  # Allow patch updates only
}</code></div>

    <h3>Changelog and Migration Guides</h3>

    <div class="code-block"><code># CHANGELOG.md
## [3.0.0] - 2026-01-15

### BREAKING CHANGES
- Renamed `worker_groups` to `node_groups` for consistency
- Removed deprecated `create_eks` variable
- Minimum Terraform version increased to 1.5.0

### Migration Guide
```hcl
# Before (v2.x)
module "eks" {
  worker_groups = {
    default = { ... }
  }
}

# After (v3.x)
module "eks" {
  node_groups = {
    default = { ... }
  }
}
```

### Added
- Support for EKS managed node groups with Bottlerocket
- Karpenter provisioner integration

### Fixed
- IAM role trust policy for IRSA</code></div>

    <h2 id="security">8. Security Best Practices</h2>

    <h3>Least Privilege IAM</h3>

    <div class="code-block"><code># Create minimal IAM policies for Terraform
data "aws_iam_policy_document" "terraform" {
  # Only allow specific actions
  statement {
    effect = "Allow"
    actions = [
      "eks:*",
      "ec2:Describe*",
      "ec2:CreateSecurityGroup",
      "ec2:DeleteSecurityGroup",
      "ec2:AuthorizeSecurityGroupIngress",
      "ec2:RevokeSecurityGroupIngress",
    ]
    resources = ["*"]
    condition {
      test     = "StringEquals"
      variable = "aws:RequestedRegion"
      values   = ["us-east-1", "us-west-2"]
    }
  }

  # Restrict state bucket access
  statement {
    effect = "Allow"
    actions = [
      "s3:GetObject",
      "s3:PutObject",
      "s3:DeleteObject",
    ]
    resources = [
      "arn:aws:s3:::company-terraform-state/*"
    ]
  }
}</code></div>

    <h3>Secrets Handling</h3>

    <div class="code-block"><code># Never store secrets in variables or state
# Instead, use data sources to fetch at apply time

data "aws_secretsmanager_secret_version" "db_password" {
  secret_id = "prod/database/master-password"
}

resource "aws_db_instance" "main" {
  # ...
  password = data.aws_secretsmanager_secret_version.db_password.secret_string
}

# For sensitive outputs, mark them appropriately
output "database_password" {
  value     = data.aws_secretsmanager_secret_version.db_password.secret_string
  sensitive = true
}</code></div>

    <h2 id="cost-optimization">9. Cost Optimization Patterns</h2>

    <h3>Resource Tagging for Cost Allocation</h3>

    <div class="code-block"><code># locals.tf
locals {
  required_tags = {
    Environment = var.environment
    Project     = var.project_name
    Owner       = var.owner_email
    CostCenter  = var.cost_center
    ManagedBy   = "terraform"
    Repository  = var.repository_url
  }

  common_tags = merge(local.required_tags, var.additional_tags)
}

# Apply to all resources via default_tags
provider "aws" {
  region = var.region

  default_tags {
    tags = local.common_tags
  }
}</code></div>

    <h3>Right-Sizing with Variables</h3>

    <div class="code-block"><code># Environment-specific sizing
variable "environment_config" {
  type = map(object({
    instance_type = string
    min_capacity  = number
    max_capacity  = number
  }))
  default = {
    dev = {
      instance_type = "t3.small"
      min_capacity  = 1
      max_capacity  = 3
    }
    staging = {
      instance_type = "t3.medium"
      min_capacity  = 2
      max_capacity  = 5
    }
    prod = {
      instance_type = "m5.large"
      min_capacity  = 3
      max_capacity  = 20
    }
  }
}

resource "aws_autoscaling_group" "main" {
  min_size = var.environment_config[var.environment].min_capacity
  max_size = var.environment_config[var.environment].max_capacity
  # ...
}</code></div>

    <h3>Parking Routines (Dev Environment Shutdown)</h3>

    <p>
      Non-production environments running 24/7 waste money. Implement automated parking to shut
      down dev/staging outside business hours:
    </p>

    <div class="code-block"><code># modules/scheduled-actions/main.tf
resource "aws_autoscaling_schedule" "scale_down_night" {
  scheduled_action_name  = "scale-down-night"
  autoscaling_group_name = var.asg_name
  
  # Scale to 0 at 7 PM (weekdays)
  recurrence = "0 19 * * MON-FRI"
  min_size   = 0
  max_size   = 0
  desired_capacity = 0
}

resource "aws_autoscaling_schedule" "scale_up_morning" {
  scheduled_action_name  = "scale-up-morning"
  autoscaling_group_name = var.asg_name
  
  # Scale back at 7 AM (weekdays)
  recurrence = "0 7 * * MON-FRI"
  min_size   = var.min_size
  max_size   = var.max_size
  desired_capacity = var.desired_capacity
}</code></div>

    <div class="lesson-learned">
      <h4>Cost Savings from Parking</h4>
      <p>
        Implementing parking routines for our 3 non-prod EKS clusters saved <strong>$4,200/month</strong>
        (65% reduction). The clusters run 50 hours/week instead of 168. Key insight: start conservative
        (parking enabled) and let teams request exceptions, not the other way around.
      </p>
    </div>

    <h3>Tagging Enforcement via OPA</h3>

    <div class="code-block"><code># policies/required_tags.rego
package terraform.analysis

deny[msg] {
  resource := input.resource_changes[_]
  resource.change.actions[_] == "create"
  
  required_tags := {"CostCenter", "Owner", "Environment", "ManagedBy"}
  provided_tags := {tag | resource.change.after.tags[tag]}
  missing := required_tags - provided_tags
  
  count(missing) > 0
  msg := sprintf(
    "Resource %s is missing required tags: %v",
    [resource.address, missing]
  )
}

# In CI pipeline
# terraform plan -out=plan.out
# terraform show -json plan.out | conftest test - --policy policies/</code></div>

    <h2 id="anti-patterns">12. Anti-Patterns to Avoid</h2>

    <p>
      These are the mistakes that cause production outages, security breaches, and endless debugging
      sessions. I've made most of these ‚Äî learn from my pain.
    </p>

    <h3>The Good, The Bad, and The Ugly</h3>

    <table>
      <thead>
        <tr>
          <th>Anti-Pattern</th>
          <th>Why It's Tempting</th>
          <th>Why It Hurts</th>
          <th>Better Approach</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong><code>count</code> for conditional resources</strong></td>
          <td>Simple toggle: count = var.enabled ? 1 : 0</td>
          <td>Index shift when adding resources ‚Üí destroys wrong ones</td>
          <td><code>for_each</code> with map keys</td>
        </tr>
        <tr>
          <td><strong>Env values in module source</strong></td>
          <td>Works for quick PoC</td>
          <td>Module not reusable, secrets in code</td>
          <td>Variables + tfvars per environment</td>
        </tr>
        <tr>
          <td><strong>S3 state without versioning</strong></td>
          <td>"We don't need history"</td>
          <td>No recovery from corruption or accidental delete</td>
          <td>Enable versioning + lifecycle rules</td>
        </tr>
        <tr>
          <td><strong>Local state for team projects</strong></td>
          <td>No setup required</td>
          <td>Concurrent modifications corrupt state</td>
          <td>Remote state with DynamoDB locking</td>
        </tr>
        <tr>
          <td><strong>Monolithic 5000+ resource modules</strong></td>
          <td>"One apply does everything"</td>
          <td>30-min plans, massive blast radius</td>
          <td>Composable modules, split states</td>
        </tr>
        <tr>
          <td><strong>Hardcoded provider versions</strong></td>
          <td>Avoid breaking changes</td>
          <td>Stuck on old versions with security vulns</td>
          <td>Pessimistic constraint: <code>~> 5.0</code></td>
        </tr>
      </tbody>
    </table>

    <div class="lesson-learned">
      <h4>The count ‚Üí for_each Migration Disaster</h4>
      <p>
        We had <code>count = length(var.subnets)</code> for subnet resources. A team reordered the
        subnet list alphabetically. Terraform planned to destroy and recreate all subnets ‚Äî in production.
        Fortunately, we caught it in PR review. We spent 2 weeks migrating to <code>for_each</code>
        with keyed maps. <strong>Rule: never use count for lists that might change order.</strong>
      </p>
    </div>

    <h3>Code Smell: Your Terraform is Broken If...</h3>

    <ul>
      <li>‚ùå <code>terraform plan</code> shows changes when nothing actually changed</li>
      <li>‚ùå You routinely use <code>-target</code> because full applies are "too risky"</li>
      <li>‚ùå State file contains resources that don't exist anymore</li>
      <li>‚ùå Multiple people run <code>terraform apply</code> without coordination</li>
      <li>‚ùå You've ever used <code>terraform state rm</code> to "fix" a problem</li>
      <li>‚ùå Your modules have 50+ required variables with no defaults</li>
    </ul>

    <h2 id="multi-account">13. Multi-Account and Multi-Region</h2>

    <h3>Provider Aliases</h3>

    <div class="code-block"><code># providers.tf
provider "aws" {
  region = "us-east-1"
  alias  = "us_east"
}

provider "aws" {
  region = "eu-west-1"
  alias  = "eu_west"
}

provider "aws" {
  alias  = "prod_account"
  region = "us-east-1"
  
  assume_role {
    role_arn = "arn:aws:iam::111111111111:role/TerraformRole"
  }
}

# Use specific provider for resources
resource "aws_s3_bucket" "us_primary" {
  provider = aws.us_east
  bucket   = "my-bucket-us"
}

resource "aws_s3_bucket" "eu_replica" {
  provider = aws.eu_west
  bucket   = "my-bucket-eu"
}</code></div>

    <h3>Multi-Region Module</h3>

    <div class="code-block"><code># modules/global-s3/main.tf
terraform {
  required_providers {
    aws = {
      source                = "hashicorp/aws"
      version               = ">= 5.0"
      configuration_aliases = [aws.primary, aws.replica]
    }
  }
}

resource "aws_s3_bucket" "primary" {
  provider = aws.primary
  bucket   = var.bucket_name
}

resource "aws_s3_bucket" "replica" {
  provider = aws.replica
  bucket   = "${var.bucket_name}-replica"
}

resource "aws_s3_bucket_replication_configuration" "primary" {
  provider = aws.primary
  bucket   = aws_s3_bucket.primary.id
  role     = aws_iam_role.replication.arn

  rule {
    status = "Enabled"
    destination {
      bucket        = aws_s3_bucket.replica.arn
      storage_class = "STANDARD_IA"
    }
  }
}</code></div>

    <h2 id="edge-cases">11. Edge Cases and Troubleshooting</h2>

    <div class="edge-case">
      <h4>‚ö†Ô∏è State Lock Stuck</h4>
      <p>State lock not released after failed apply:</p>
      <div class="code-block"><code># Force unlock (use with caution!)
terraform force-unlock LOCK_ID

# Check DynamoDB for stuck locks
aws dynamodb scan --table-name terraform-state-lock</code></div>
    </div>

    <div class="edge-case">
      <h4>‚ö†Ô∏è Resource Already Exists</h4>
      <p>Trying to create a resource that already exists outside Terraform:</p>
      <div class="code-block"><code># Import existing resource into state
terraform import aws_s3_bucket.example my-existing-bucket

# Verify with plan
terraform plan</code></div>
    </div>

    <div class="edge-case">
      <h4>‚ö†Ô∏è Provider Version Mismatch</h4>
      <p>Different team members using different provider versions:</p>
      <div class="code-block"><code># Use .terraform.lock.hcl and commit it
terraform providers lock -platform=darwin_amd64 -platform=linux_amd64

# Upgrade providers consistently
terraform init -upgrade</code></div>
    </div>

    <div class="edge-case">
      <h4>‚ö†Ô∏è Circular Dependencies</h4>
      <p>Resources that depend on each other:</p>
      <div class="code-block"><code># Use depends_on for explicit ordering
resource "aws_security_group" "a" {
  name = "sg-a"
}

resource "aws_security_group" "b" {
  name = "sg-b"
  depends_on = [aws_security_group.a]
}

# Or break the cycle with data sources
resource "aws_security_group_rule" "a_to_b" {
  security_group_id        = aws_security_group.a.id
  source_security_group_id = aws_security_group.b.id
  # ...
}</code></div>
    </div>

    <h2 id="migration">12. Migration and Upgrade Strategies</h2>

    <h3>State Migration with moved Blocks</h3>

    <div class="code-block"><code># Rename a resource without destroy/recreate
moved {
  from = aws_instance.web_server
  to   = aws_instance.application_server
}

# Move into a module
moved {
  from = aws_instance.web
  to   = module.web_servers.aws_instance.this
}

# Move from count to for_each
moved {
  from = aws_instance.web[0]
  to   = aws_instance.web["primary"]
}</code></div>

    <h3>Blue-Green Infrastructure Deployment</h3>

    <div class="code-block"><code># Use create_before_destroy for zero-downtime
resource "aws_launch_template" "app" {
  name_prefix = "app-"
  
  lifecycle {
    create_before_destroy = true
  }
}

# Or use workspaces for parallel environments
terraform workspace new blue
terraform apply -var="color=blue"

terraform workspace new green  
terraform apply -var="color=green"

# Switch traffic at load balancer level</code></div>

    <h2>Key Takeaways</h2>

    <ol>
      <li><strong>Design for reuse:</strong> Build modules with clear interfaces and sensible defaults</li>
      <li><strong>Isolate state:</strong> Use separate state files per environment and component</li>
      <li><strong>Test everything:</strong> Static analysis, unit tests, and policy checks before apply</li>
      <li><strong>Version carefully:</strong> Use semantic versioning and provide migration guides</li>
      <li><strong>Secure by default:</strong> Least privilege IAM, encrypted state, no secrets in code</li>
      <li><strong>Plan for scale:</strong> Multi-account, multi-region patterns from the start</li>
    </ol>

    <div class="footer">
      <p>Need help scaling your Terraform infrastructure?</p>
      <a href="/portfolio/#contact" class="cta">Get in Touch ‚Üí</a>
    </div>
  </article>
  <script src="article-interactive.js"></script>
</body>

</html>