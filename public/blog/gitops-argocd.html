<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GitOps Best Practices with ArgoCD | Chandra Koushik Kodali</title>
  <meta name="description"
    content="A comprehensive guide to implementing GitOps workflows for Kubernetes deployments with ArgoCD, including multi-environment strategies and zero-downtime deployments.">
  <meta name="author" content="Chandra Koushik Kodali">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      /* Dark Theme (Default) */
      --bg-primary: #030014;
      --bg-gradient-start: #030014;
      --bg-gradient-end: #0a0a1f;
      --text-primary: #e5e7eb;
      --text-secondary: #9ca3af;
      --text-muted: #6b7280;
      --accent: #8b5cf6;
      --accent-hover: #a78bfa;
      --border: rgba(255, 255, 255, 0.1);
      --card-bg: rgba(255, 255, 255, 0.03);
      --code-bg: #0d1117;
      --heading-gradient-start: #fff;
      --heading-gradient-end: #c4b5fd;
      --heading-color: #fff;
      --table-header-bg: rgba(255, 255, 255, 0.05);
    }

    .light {
      /* Light Theme */
      --bg-primary: #ffffff;
      --bg-gradient-start: #ffffff;
      --bg-gradient-end: #f9fafb;
      --text-primary: #1f2937;
      --text-secondary: #4b5563;
      --text-muted: #6b7280;
      --accent: #7c3aed;
      --accent-hover: #6d28d9;
      --border: #e5e7eb;
      --card-bg: #f3f4f6;
      --code-bg: #1f2937;
      --heading-gradient-start: #111827;
      --heading-gradient-end: #374151;
      --heading-color: #111827;
      --table-header-bg: #f3f4f6;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background: var(--bg-primary);
      background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
      color: var(--text-primary);
      line-height: 1.8;
      min-height: 100vh;
      transition: background 0.3s, color 0.3s;
    }

    .container {
      max-width: 800px;
      margin: 0 auto;
      padding: 60px 24px;
      position: relative;
    }

    .nav-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 40px;
    }

    .theme-toggle {
      background: var(--card-bg);
      border: 1px solid var(--border);
      color: var(--text-secondary);
      cursor: pointer;
      padding: 8px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }

    .theme-toggle:hover {
      color: var(--text-primary);
      border-color: var(--accent);
    }

    .back-link {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      color: var(--accent);
      text-decoration: none;
      font-size: 14px;
      transition: color 0.2s;
    }

    .back-link:hover {
      color: var(--accent-hover);
    }

    .tag {
      display: inline-block;
      padding: 4px 12px;
      background: rgba(139, 92, 246, 0.15);
      border: 1px solid rgba(139, 92, 246, 0.3);
      border-radius: 9999px;
      color: var(--accent);
      font-size: 12px;
      font-weight: 500;
      margin-bottom: 16px;
    }

    h1 {
      font-size: 2.5rem;
      font-weight: 700;
      background: linear-gradient(to right, var(--heading-gradient-start), var(--heading-gradient-end));
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 16px;
      line-height: 1.2;
      color: var(--heading-color);
    }

    .meta {
      color: var(--text-muted);
      font-size: 14px;
      margin-bottom: 40px;
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
    }

    h2 {
      font-size: 1.5rem;
      color: var(--heading-color);
      margin: 48px 0 16px;
      padding-bottom: 8px;
      border-bottom: 1px solid var(--border);
    }

    h3 {
      font-size: 1.25rem;
      color: var(--text-primary);
      margin: 32px 0 12px;
    }

    h4 {
      font-size: 1.1rem;
      color: var(--text-secondary);
      margin: 24px 0 10px;
    }

    p {
      margin-bottom: 20px;
      color: var(--text-secondary);
    }

    ul,
    ol {
      margin: 0 0 20px 24px;
      color: var(--text-secondary);
    }

    li {
      margin-bottom: 8px;
    }

    .code-block {
      background: #0d1117;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 20px;
      margin: 20px 0;
      overflow-x: auto;
      font-family: 'Fira Code', monospace;
      font-size: 14px;
      color: #c9d1d9;
    }

    .code-block code {
      white-space: pre;
    }

    .highlight {
      background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(6, 182, 212, 0.1));
      border-left: 3px solid var(--accent);
      padding: 16px 20px;
      margin: 24px 0;
      border-radius: 0 12px 12px 0;
    }

    .warning {
      background: linear-gradient(135deg, rgba(245, 158, 11, 0.1), rgba(239, 68, 68, 0.1));
      border-left: 3px solid #f59e0b;
      padding: 16px 20px;
      margin: 24px 0;
      border-radius: 0 12px 12px 0;
    }

    .key-point {
      background: rgba(16, 185, 129, 0.1);
      border: 1px solid rgba(16, 185, 129, 0.3);
      border-radius: 12px;
      padding: 20px;
      margin: 24px 0;
    }

    .key-point h4 {
      color: #10b981;
      margin-bottom: 8px;
      font-size: 14px;
      margin-top: 0;
    }

    .edge-case {
      background: rgba(239, 68, 68, 0.1);
      border: 1px solid rgba(239, 68, 68, 0.3);
      border-radius: 12px;
      padding: 20px;
      margin: 24px 0;
    }

    .edge-case h4 {
      color: #ef4444;
      margin-bottom: 8px;
      font-size: 14px;
      margin-top: 0;
    }

    strong {
      color: var(--heading-color);
    }

    .toc {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 24px;
      margin: 32px 0;
    }

    .toc h3 {
      margin-top: 0;
      margin-bottom: 16px;
      color: var(--heading-color);
    }

    .toc ul {
      margin: 0;
      list-style: none;
      padding-left: 0;
    }

    .toc li {
      margin-bottom: 8px;
    }

    .toc a {
      color: var(--accent);
      text-decoration: none;
    }

    .toc a:hover {
      text-decoration: underline;
    }

    .diagram {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 32px;
      margin: 32px 0;
      overflow-x: auto;
    }

    .diagram-title {
      font-size: 14px;
      color: var(--text-muted);
      text-align: center;
      margin-bottom: 24px;
      font-weight: 500;
    }

    .diagram svg {
      display: block;
      margin: 0 auto;
      max-width: 100%;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
      font-size: 14px;
    }

    th,
    td {
      padding: 12px;
      text-align: left;
      border-bottom: 1px solid var(--border);
    }

    th {
      color: var(--heading-color);
      background: var(--table-header-bg);
    }

    td {
      color: var(--text-secondary);
    }

    .footer {
      margin-top: 60px;
      padding-top: 40px;
      border-top: 1px solid var(--border);
      text-align: center;
      color: var(--text-muted);
      font-size: 14px;
    }

    .cta {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      background: linear-gradient(135deg, var(--accent), #06b6d4);
      color: #fff;
      padding: 12px 24px;
      border-radius: 12px;
      text-decoration: none;
      font-weight: 500;
      margin-top: 20px;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .cta:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 40px rgba(139, 92, 246, 0.3);
    }
  </style>
  <link rel="stylesheet" href="article-interactive.css">
  <script>
    // Check for theme preference
    const savedTheme = localStorage.getItem('theme');
    if (savedTheme === 'light') {
      document.documentElement.classList.add('light');
    }

    function toggleTheme() {
      const isLight = document.documentElement.classList.toggle('light');
      localStorage.setItem('theme', isLight ? 'light' : 'dark');
    }
  </script>
</head>

<body>
  <article class="container">
    <div class="nav-header">
      <a href="/portfolio/#articles" class="back-link">
        ‚Üê Back to Portfolio
      </a>
      <button class="theme-toggle" onclick="toggleTheme()" title="Toggle Theme">
        <!-- Sun Icon -->
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
          stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="12" cy="12" r="5"></circle>
          <line x1="12" y1="1" x2="12" y2="3"></line>
          <line x1="12" y1="21" x2="12" y2="23"></line>
          <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
          <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
          <line x1="1" y1="12" x2="3" y2="12"></line>
          <line x1="21" y1="12" x2="23" y2="12"></line>
          <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
          <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
        </svg>
      </button>
    </div>

    <span class="tag">DevOps</span>
    <h1>GitOps Best Practices with ArgoCD</h1>

    <div class="meta">
      <span>By Chandra Koushik Kodali</span>
      <span>‚Ä¢</span>
      <span>22 min read</span>
      <span>‚Ä¢</span>
      <span>January 2026</span>
    </div>

    <p>
      GitOps has revolutionized how we deploy and manage applications on Kubernetes. By treating Git as the single
      source of truth for declarative infrastructure and applications, teams gain unprecedented visibility,
      auditability, and control over their deployments. In this comprehensive guide, I'll share battle-tested
      patterns and practices for implementing GitOps with ArgoCD at scale.
    </p>

    <a href="https://github.com/chandrakodali/terraform-aws-eks-platform" target="_blank" class="github-link">
      <svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg">
        <path fill-rule="evenodd"
          d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z" />
      </svg>
      <span>
        <span class="repo-name">chandrakodali/terraform-aws-eks-platform</span>
        <span class="repo-desc">See GitOps patterns applied in a real EKS infrastructure project</span>
      </span>
    </a>

    <div class="real-world">
      <h4>From My Experience</h4>
      <p>
        When we first adopted GitOps, our team was skeptical. "Another tool to learn?" they said. But within
        3 months, deployment failures dropped by <strong>78%</strong> and mean time to recovery (MTTR) went from
        hours to minutes. The key insight: GitOps isn't just about tooling ‚Äî it's about creating a <strong>culture
          of declarative, auditable changes</strong>. Every production incident became a learning opportunity
        because we could trace exactly what changed and when.
      </p>
    </div>

    <div class="toc">
      <h3>Table of Contents</h3>
      <ul>
        <li><a href="#gitops-principles">1. GitOps Principles and Philosophy</a></li>
        <li><a href="#architecture-decisions">2. Architecture Decision Records</a></li>
        <li><a href="#argocd-architecture">3. ArgoCD Architecture Deep Dive</a></li>
        <li><a href="#repository-strategies">4. Repository Structure Strategies</a></li>
        <li><a href="#multi-environment">5. Multi-Environment Management</a></li>
        <li><a href="#deployment-strategies">6. Deployment Strategies</a></li>
        <li><a href="#secrets-management">7. Secrets Management</a></li>
        <li><a href="#rbac-multitenancy">8. RBAC and Multi-Tenancy</a></li>
        <li><a href="#sync-strategies">9. Sync Strategies and Hooks</a></li>
        <li><a href="#day2-operations">10. Day 2 Operations at Scale</a></li>
        <li><a href="#rollback-recovery">11. Rollback and Disaster Recovery</a></li>
        <li><a href="#monitoring">12. Monitoring and Alerting</a></li>
        <li><a href="#anti-patterns">13. Anti-Patterns to Avoid</a></li>
        <li><a href="#edge-cases">14. Edge Cases and Troubleshooting</a></li>
        <li><a href="#security-hardening">15. Security Hardening</a></li>
      </ul>
    </div>

    <h2 id="gitops-principles">1. GitOps Principles and Philosophy</h2>

    <p>GitOps is built on four fundamental principles that differentiate it from traditional CI/CD approaches:</p>

    <h3>Declarative Configuration</h3>
    <p>
      Everything about your system ‚Äî infrastructure, applications, policies ‚Äî is described declaratively. This
      means you define <em>what</em> you want, not <em>how</em> to get there. Kubernetes manifests, Helm charts,
      and Kustomize overlays are all declarative by nature.
    </p>

    <h3>Versioned and Immutable</h3>
    <p>
      The desired state is stored in Git, providing a complete version history. Every change is tracked, authored,
      and can be audited. You can always answer "who changed what, when, and why?"
    </p>

    <h3>Pulled Automatically</h3>
    <p>
      Unlike traditional CI/CD where changes are pushed to the cluster, GitOps agents <em>pull</em> the desired
      state and apply it. This eliminates the need to expose cluster credentials to external systems.
    </p>

    <h3>Continuously Reconciled</h3>
    <p>
      GitOps agents continuously compare the actual state with the desired state and automatically correct any
      drift. If someone manually changes something in the cluster (kubectl edit), the agent will revert it.
    </p>

    <div class="highlight">
      <strong>The GitOps Promise:</strong> If it's in Git, it's in the cluster. If it's not in Git, it's not in
      the cluster. This simple guarantee transforms how teams think about deployments and operations.
    </div>

    <div class="diagram">
      <div class="diagram-title">Figure 1: GitOps Reconciliation Loop</div>
      <svg viewBox="0 0 700 300" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <linearGradient id="gitGrad" x1="0%" y1="0%" x2="100%" y2="0%">
            <stop offset="0%" style="stop-color:#f59e0b;stop-opacity:0.3" />
            <stop offset="100%" style="stop-color:#ef4444;stop-opacity:0.3" />
          </linearGradient>
          <linearGradient id="argoGrad2" x1="0%" y1="0%" x2="100%" y2="0%">
            <stop offset="0%" style="stop-color:#8b5cf6;stop-opacity:0.3" />
            <stop offset="100%" style="stop-color:#06b6d4;stop-opacity:0.3" />
          </linearGradient>
          <linearGradient id="k8sGrad2" x1="0%" y1="0%" x2="100%" y2="0%">
            <stop offset="0%" style="stop-color:#3b82f6;stop-opacity:0.3" />
            <stop offset="100%" style="stop-color:#10b981;stop-opacity:0.3" />
          </linearGradient>
        </defs>

        <!-- Git Repository -->
        <rect x="30" y="100" width="150" height="100" rx="12" fill="url(#gitGrad)" stroke="#f59e0b" stroke-width="2" />
        <text x="105" y="140" fill="#f59e0b" font-size="14" font-weight="600" text-anchor="middle">Git Repository</text>
        <text x="105" y="160" fill="#9ca3af" font-size="11" text-anchor="middle">Desired State</text>
        <text x="105" y="180" fill="#9ca3af" font-size="10" text-anchor="middle">(YAML, Helm, Kustomize)</text>

        <!-- ArgoCD -->
        <rect x="275" y="100" width="150" height="100" rx="12" fill="url(#argoGrad2)" stroke="#8b5cf6"
          stroke-width="2" />
        <text x="350" y="140" fill="#8b5cf6" font-size="14" font-weight="600" text-anchor="middle">ArgoCD</text>
        <text x="350" y="160" fill="#9ca3af" font-size="11" text-anchor="middle">Reconciliation</text>
        <text x="350" y="180" fill="#9ca3af" font-size="10" text-anchor="middle">(Compare & Sync)</text>

        <!-- Kubernetes -->
        <rect x="520" y="100" width="150" height="100" rx="12" fill="url(#k8sGrad2)" stroke="#3b82f6"
          stroke-width="2" />
        <text x="595" y="140" fill="#3b82f6" font-size="14" font-weight="600" text-anchor="middle">Kubernetes</text>
        <text x="595" y="160" fill="#9ca3af" font-size="11" text-anchor="middle">Actual State</text>
        <text x="595" y="180" fill="#9ca3af" font-size="10" text-anchor="middle">(Running Workloads)</text>

        <!-- Arrows -->
        <!-- Git to ArgoCD -->
        <path d="M180 130 L270 130" stroke="#9ca3af" stroke-width="2" />
        <polygon points="275,130 265,125 265,135" fill="#9ca3af" />
        <text x="225" y="120" fill="#9ca3af" font-size="10" text-anchor="middle">Pull</text>

        <!-- ArgoCD to K8s -->
        <path d="M425 130 L515 130" stroke="#9ca3af" stroke-width="2" />
        <polygon points="520,130 510,125 510,135" fill="#9ca3af" />
        <text x="470" y="120" fill="#9ca3af" font-size="10" text-anchor="middle">Apply</text>

        <!-- K8s to ArgoCD (Monitor) -->
        <path d="M520 170 L425 170" stroke="#6b7280" stroke-width="2" stroke-dasharray="4" />
        <polygon points="425,170 435,165 435,175" fill="#6b7280" />
        <text x="470" y="190" fill="#6b7280" font-size="10" text-anchor="middle">Monitor</text>

        <!-- Loop indicator -->
        <circle cx="350" cy="50" r="25" fill="none" stroke="#10b981" stroke-width="2" stroke-dasharray="4" />
        <text x="350" y="55" fill="#10b981" font-size="12" text-anchor="middle">‚àû</text>
        <text x="350" y="30" fill="#10b981" font-size="10" text-anchor="middle">Continuous</text>

        <!-- Drift Detection -->
        <rect x="520" y="230" width="150" height="40" rx="8" fill="rgba(239, 68, 68, 0.1)" stroke="#ef4444"
          stroke-width="1" />
        <text x="595" y="255" fill="#ef4444" font-size="11" text-anchor="middle">Drift Detected? ‚Üí Auto-heal</text>
        <path d="M595 200 L595 225" stroke="#ef4444" stroke-width="1" stroke-dasharray="3" />
      </svg>
    </div>

    <h2 id="architecture-decisions">2. Architecture Decision Records</h2>

    <p>
      Before diving into implementation, let's document the key architectural decisions that shape our GitOps
      strategy. Understanding <em>why</em> we chose certain tools over alternatives is what separates senior
      engineers from those who just follow tutorials.
    </p>

    <h3>ADR 1: Why ArgoCD Over Flux?</h3>

    <p>
      Both ArgoCD and Flux are CNCF projects for GitOps. Here's our decision matrix:
    </p>

    <table>
      <thead>
        <tr>
          <th>Criteria</th>
          <th>ArgoCD</th>
          <th>Flux</th>
          <th>Winner</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>UI/Dashboard</strong></td>
          <td>Built-in, feature-rich</td>
          <td>Requires Weave GitOps (separate)</td>
          <td>ArgoCD</td>
        </tr>
        <tr>
          <td><strong>Multi-cluster</strong></td>
          <td>Single pane of glass</td>
          <td>Per-cluster controllers</td>
          <td>ArgoCD</td>
        </tr>
        <tr>
          <td><strong>RBAC</strong></td>
          <td>Fine-grained, SSO via Dex</td>
          <td>K8s RBAC only</td>
          <td>ArgoCD</td>
        </tr>
        <tr>
          <td><strong>Resource footprint</strong></td>
          <td>Higher (3+ components)</td>
          <td>Lower (controllers only)</td>
          <td>Flux</td>
        </tr>
        <tr>
          <td><strong>Helm support</strong></td>
          <td>Native + templating</td>
          <td>Native via HelmRelease</td>
          <td>Tie</td>
        </tr>
        <tr>
          <td><strong>Learning curve</strong></td>
          <td>Moderate</td>
          <td>Steeper (CRD-heavy)</td>
          <td>ArgoCD</td>
        </tr>
      </tbody>
    </table>

    <div class="lesson-learned">
      <h4>Decision Context</h4>
      <p>
        We chose ArgoCD because our platform serves multiple development teams who need self-service visibility into
        deployments. The built-in UI reduced support tickets significantly ‚Äî developers could see sync status without
        asking the platform team. For teams with strong GitOps maturity and no UI requirements, Flux's
        lighter footprint may be preferable.
      </p>
    </div>

    <h3>ADR 2: Why Kustomize Over Helm for Platform Components?</h3>

    <p>We use Kustomize for platform infrastructure and Helm for third-party applications. Here's why:</p>

    <table>
      <thead>
        <tr>
          <th>Aspect</th>
          <th>Kustomize</th>
          <th>Helm</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>Philosophy</strong></td>
          <td>Patching over templating</td>
          <td>Templating with Go templates</td>
        </tr>
        <tr>
          <td><strong>Git readability</strong></td>
          <td>‚úÖ Fully rendered YAML visible</td>
          <td>‚ùå Templates obscure final output</td>
        </tr>
        <tr>
          <td><strong>ArgoCD state</strong></td>
          <td>No release state conflicts</td>
          <td>Helm release secrets can desync</td>
        </tr>
        <tr>
          <td><strong>Customization</strong></td>
          <td>Overlays for environments</td>
          <td>Values files per environment</td>
        </tr>
        <tr>
          <td><strong>Third-party charts</strong></td>
          <td>Must vendor or use Helm</td>
          <td>‚úÖ Direct from registries</td>
        </tr>
      </tbody>
    </table>

    <div class="real-world">
      <h4>From My Experience</h4>
      <p>
        In our <a href="https://github.com/chandrakodali/terraform-aws-eks-platform" target="_blank">EKS platform</a>,
        we use Kustomize for our own components (RBAC, namespaces, quotas) because we can see exactly what's
        deployed in Git. We use Helm for third-party tools like cert-manager and external-dns because
        maintaining forks of those charts would be painful. <strong>The rule: own your abstractions,
          delegate commodity tools.</strong>
      </p>
    </div>

    <h3>ADR 3: Self-Managed vs. Managed ArgoCD?</h3>

    <p>
      Cloud providers and vendors offer managed ArgoCD (AWS EKS Blueprints, Akuity). Here's our analysis:
    </p>

    <table>
      <thead>
        <tr>
          <th>Factor</th>
          <th>Self-Managed</th>
          <th>Managed (e.g., Akuity)</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>Operational overhead</strong></td>
          <td>You manage upgrades, HA, DR</td>
          <td>Vendor handles operations</td>
        </tr>
        <tr>
          <td><strong>Cost at scale (500+ apps)</strong></td>
          <td>~$200/month (compute)</td>
          <td>~$1,500+/month (licensing)</td>
        </tr>
        <tr>
          <td><strong>Customization</strong></td>
          <td>Full control</td>
          <td>Limited to vendor features</td>
        </tr>
        <tr>
          <td><strong>Network security</strong></td>
          <td>Stays in your VPC</td>
          <td>SaaS egress concerns</td>
        </tr>
        <tr>
          <td><strong>Support</strong></td>
          <td>Community + internal</td>
          <td>Enterprise SLA</td>
        </tr>
      </tbody>
    </table>

    <div class="lesson-learned">
      <h4>Our Decision</h4>
      <p>
        We run self-managed ArgoCD because: (1) cost savings at scale are significant, (2) we need custom
        RBAC integrations with our identity provider, and (3) security requires Git and cluster traffic
        to stay within our VPC. For startups without a platform team, managed solutions reduce time-to-value.
      </p>
    </div>

    <h2 id="argocd-architecture">3. ArgoCD Architecture Deep Dive</h2>

    <p>Understanding ArgoCD's architecture is essential for operating it effectively at scale.</p>

    <div class="diagram">
      <div class="diagram-title">Figure 1: ArgoCD Architecture</div>
      <svg viewBox="0 0 700 400" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <linearGradient id="argoGrad" x1="0%" y1="0%" x2="100%" y2="0%">
            <stop offset="0%" style="stop-color:#8b5cf6;stop-opacity:0.2" />
            <stop offset="100%" style="stop-color:#06b6d4;stop-opacity:0.2" />
          </linearGradient>
        </defs>

        <!-- Git Repository -->
        <rect x="30" y="50" width="120" height="60" rx="8" fill="#0d1117" stroke="#f59e0b" stroke-width="2" />
        <text x="90" y="75" fill="#f59e0b" font-size="12" text-anchor="middle">Git Repository</text>
        <text x="90" y="95" fill="#9ca3af" font-size="10" text-anchor="middle">Source of Truth</text>

        <!-- ArgoCD Components Box -->
        <rect x="200" y="20" width="300" height="280" rx="12" fill="url(#argoGrad)" stroke="#8b5cf6" stroke-width="1" />
        <text x="350" y="45" fill="#8b5cf6" font-size="14" font-weight="600" text-anchor="middle">ArgoCD
          Components</text>

        <!-- API Server -->
        <rect x="220" y="60" width="120" height="50" rx="8" fill="#0d1117" stroke="#8b5cf6" stroke-width="1" />
        <text x="280" y="85" fill="#e5e7eb" font-size="11" text-anchor="middle">API Server</text>
        <text x="280" y="100" fill="#9ca3af" font-size="9" text-anchor="middle">REST/gRPC API</text>

        <!-- Repo Server -->
        <rect x="360" y="60" width="120" height="50" rx="8" fill="#0d1117" stroke="#8b5cf6" stroke-width="1" />
        <text x="420" y="85" fill="#e5e7eb" font-size="11" text-anchor="middle">Repo Server</text>
        <text x="420" y="100" fill="#9ca3af" font-size="9" text-anchor="middle">Manifest Generation</text>

        <!-- Application Controller -->
        <rect x="220" y="130" width="120" height="50" rx="8" fill="#0d1117" stroke="#8b5cf6" stroke-width="1" />
        <text x="280" y="155" fill="#e5e7eb" font-size="11" text-anchor="middle">App Controller</text>
        <text x="280" y="170" fill="#9ca3af" font-size="9" text-anchor="middle">Reconciliation</text>

        <!-- Redis -->
        <rect x="360" y="130" width="120" height="50" rx="8" fill="#0d1117" stroke="#8b5cf6" stroke-width="1" />
        <text x="420" y="155" fill="#e5e7eb" font-size="11" text-anchor="middle">Redis</text>
        <text x="420" y="170" fill="#9ca3af" font-size="9" text-anchor="middle">Cache</text>

        <!-- Dex -->
        <rect x="220" y="200" width="120" height="50" rx="8" fill="#0d1117" stroke="#8b5cf6" stroke-width="1" />
        <text x="280" y="225" fill="#e5e7eb" font-size="11" text-anchor="middle">Dex</text>
        <text x="280" y="240" fill="#9ca3af" font-size="9" text-anchor="middle">SSO/OIDC</text>

        <!-- Notifications -->
        <rect x="360" y="200" width="120" height="50" rx="8" fill="#0d1117" stroke="#8b5cf6" stroke-width="1" />
        <text x="420" y="225" fill="#e5e7eb" font-size="11" text-anchor="middle">Notifications</text>
        <text x="420" y="240" fill="#9ca3af" font-size="9" text-anchor="middle">Alerts/Webhooks</text>

        <!-- Kubernetes Cluster -->
        <rect x="550" y="50" width="120" height="60" rx="8" fill="#0d1117" stroke="#3b82f6" stroke-width="2" />
        <text x="610" y="75" fill="#3b82f6" font-size="12" text-anchor="middle">Kubernetes</text>
        <text x="610" y="95" fill="#9ca3af" font-size="10" text-anchor="middle">Target Cluster</text>

        <!-- Arrows -->
        <path d="M150 80 L195 80" stroke="#6b7280" stroke-width="2" />
        <polygon points="200,80 190,75 190,85" fill="#6b7280" />

        <path d="M505 130 L545 80" stroke="#6b7280" stroke-width="2" />
        <polygon points="550,75 540,80 545,90" fill="#6b7280" />

        <!-- Users -->
        <rect x="30" y="320" width="120" height="50" rx="8" fill="#0d1117" stroke="#06b6d4" stroke-width="2" />
        <text x="90" y="345" fill="#06b6d4" font-size="12" text-anchor="middle">Users/CI</text>
        <text x="90" y="360" fill="#9ca3af" font-size="10" text-anchor="middle">UI/CLI/API</text>

        <path d="M150 345 L270 270" stroke="#6b7280" stroke-width="2" stroke-dasharray="4" />
      </svg>
    </div>

    <h3>Key Components</h3>

    <table>
      <tr>
        <th>Component</th>
        <th>Purpose</th>
        <th>Scaling Considerations</th>
      </tr>
      <tr>
        <td>API Server</td>
        <td>Exposes REST/gRPC API, serves UI</td>
        <td>Stateless, can be horizontally scaled</td>
      </tr>
      <tr>
        <td>Repo Server</td>
        <td>Clones repos, generates manifests</td>
        <td>CPU intensive, scale based on repo count</td>
      </tr>
      <tr>
        <td>Application Controller</td>
        <td>Monitors apps, performs sync</td>
        <td>Single leader with sharding support</td>
      </tr>
      <tr>
        <td>Redis</td>
        <td>Caches manifests and app state</td>
        <td>Consider Redis Cluster for HA</td>
      </tr>
      <tr>
        <td>Dex</td>
        <td>OIDC provider for SSO</td>
        <td>Stateless, scale as needed</td>
      </tr>
    </table>

    <h2 id="repository-strategies">3. Repository Structure Strategies</h2>

    <p>How you structure your GitOps repositories significantly impacts maintainability and scalability.</p>

    <h3>Mono-Repository Approach</h3>
    <p>All applications and environments in a single repository:</p>

    <div class="code-block"><code>gitops-repo/
‚îú‚îÄ‚îÄ apps/
‚îÇ   ‚îú‚îÄ‚îÄ team-a/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ app-1/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ base/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deployment.yaml
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ service.yaml
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ kustomization.yaml
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ overlays/
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ dev/
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ staging/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ prod/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ app-2/
‚îÇ   ‚îî‚îÄ‚îÄ team-b/
‚îú‚îÄ‚îÄ infrastructure/
‚îÇ   ‚îú‚îÄ‚îÄ argocd/
‚îÇ   ‚îú‚îÄ‚îÄ cert-manager/
‚îÇ   ‚îî‚îÄ‚îÄ monitoring/
‚îî‚îÄ‚îÄ clusters/
    ‚îú‚îÄ‚îÄ dev/
    ‚îú‚îÄ‚îÄ staging/
    ‚îî‚îÄ‚îÄ prod/</code></div>

    <div class="key-point">
      <h4>üí° When to Use Mono-Repo</h4>
      <ul>
        <li>Smaller organizations (&lt;50 developers)</li>
        <li>Strong code review culture</li>
        <li>Need atomic changes across multiple apps</li>
        <li>Centralized platform team</li>
      </ul>
    </div>

    <h3>Multi-Repository Approach</h3>
    <p>Separate repositories per team or application:</p>

    <div class="code-block"><code># Team-owned repos
team-a-apps/
‚îú‚îÄ‚îÄ app-1/
‚îî‚îÄ‚îÄ app-2/

team-b-apps/
‚îú‚îÄ‚îÄ app-3/
‚îî‚îÄ‚îÄ app-4/

# Platform-owned repos
platform-infrastructure/
‚îú‚îÄ‚îÄ argocd/
‚îú‚îÄ‚îÄ cert-manager/
‚îî‚îÄ‚îÄ monitoring/

cluster-config/
‚îú‚îÄ‚îÄ dev/
‚îú‚îÄ‚îÄ staging/
‚îî‚îÄ‚îÄ prod/</code></div>

    <div class="key-point">
      <h4>üí° When to Use Multi-Repo</h4>
      <ul>
        <li>Larger organizations with autonomous teams</li>
        <li>Different access control requirements</li>
        <li>Independent release cycles</li>
        <li>Compliance requirements for separation</li>
      </ul>
    </div>

    <div class="lesson-learned">
      <h4>Lesson Learned: Why We Started with Mono-Repo Then Migrated</h4>
      <p>
        In my <a href="https://github.com/chandrakodali/terraform-aws-eks-platform" target="_blank">platform
          project</a>,
        we started with a mono-repo because it was simpler to manage with our small team. As we scaled to
        15+ microservices across 4 teams, we hit pain points: <strong>PR bottlenecks</strong>,
        <strong>accidental changes to other teams' apps</strong>, and <strong>slow CI pipelines</strong> processing
        the entire repo. We migrated to a hybrid model: platform infrastructure in a mono-repo (managed by platform
        team),
        application manifests in team-owned repos. This gave teams autonomy while maintaining platform consistency.
      </p>
    </div>

    <h2 id="multi-environment">4. Multi-Environment Management</h2>

    <p>Managing multiple environments (dev, staging, prod) requires careful design to balance consistency with
      flexibility.</p>

    <h3>Using Kustomize Overlays</h3>
    <p>
      Kustomize allows you to define a base configuration and patch it for different environments. This keeps your
      YAML DRY (Don't Repeat Yourself):
    </p>

    <div class="code-block"><code># base/kustomization.yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization
resources:
  - deployment.yaml
  - service.yaml
  - configmap.yaml

# overlays/prod/kustomization.yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization
resources:
  - ../../base
namePrefix: prod-
namespace: production
patches:
  - path: replica-patch.yaml
  - path: resource-patch.yaml
images:
  - name: myapp
    newTag: v1.2.3

# overlays/prod/replica-patch.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  replicas: 5</code></div>

    <h3>ApplicationSet for Multi-Environment</h3>

    <p>Use ApplicationSets to generate applications across environments:</p>

    <div class="code-block"><code>apiVersion: argoproj.io/v1alpha1
kind: ApplicationSet
metadata:
  name: myapp
  namespace: argocd
spec:
  generators:
    - list:
        elements:
          - env: dev
            cluster: https://dev-cluster.example.com
            replicas: "1"
          - env: staging
            cluster: https://staging-cluster.example.com
            replicas: "2"
          - env: prod
            cluster: https://prod-cluster.example.com
            replicas: "5"
  template:
    metadata:
      name: 'myapp-{{env}}'
    spec:
      project: default
      source:
        repoURL: https://github.com/org/gitops
        targetRevision: main
        path: 'apps/myapp/overlays/{{env}}'
      destination:
        server: '{{cluster}}'
        namespace: 'myapp-{{env}}'
      syncPolicy:
        automated:
          prune: true
          selfHeal: true</code></div>

    <h2 id="deployment-strategies">5. Deployment Strategies</h2>

    <h3>Blue-Green Deployments</h3>
    <p>Run two identical environments, switch traffic atomically:</p>

    <div class="code-block"><code>apiVersion: argoproj.io/v1alpha1
kind: Rollout
metadata:
  name: myapp
spec:
  replicas: 5
  strategy:
    blueGreen:
      activeService: myapp-active
      previewService: myapp-preview
      autoPromotionEnabled: false
      scaleDownDelaySeconds: 30
      prePromotionAnalysis:
        templates:
          - templateName: success-rate
        args:
          - name: service-name
            value: myapp-preview
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
        - name: myapp
          image: myapp:v2
          ports:
            - containerPort: 8080</code></div>

    <h3>Canary Deployments</h3>
    <p>Gradually shift traffic to the new version:</p>

    <div class="code-block"><code>apiVersion: argoproj.io/v1alpha1
kind: Rollout
metadata:
  name: myapp
spec:
  replicas: 10
  strategy:
    canary:
      steps:
        - setWeight: 5
        - pause: { duration: 5m }
        - setWeight: 20
        - pause: { duration: 10m }
        - setWeight: 50
        - pause: { duration: 10m }
        - setWeight: 80
        - pause: { duration: 5m }
      analysis:
        templates:
          - templateName: success-rate
        startingStep: 2
        args:
          - name: service-name
            value: myapp-canary
      canaryService: myapp-canary
      stableService: myapp-stable
      trafficRouting:
        istio:
          virtualService:
            name: myapp-vsvc
            routes:
              - primary</code></div>

    <h2 id="secrets-management">6. Secrets Management</h2>

    <p>Never store secrets in Git. Here are secure alternatives:</p>

    <h3>Sealed Secrets</h3>
    <p>Encrypt secrets that can only be decrypted by the cluster:</p>

    <div class="code-block"><code># Create a sealed secret
kubeseal --format yaml &lt; secret.yaml &gt; sealed-secret.yaml

# The sealed secret can be safely committed to Git
apiVersion: bitnami.com/v1alpha1
kind: SealedSecret
metadata:
  name: mysecret
  namespace: myapp
spec:
  encryptedData:
    password: AgBy8hCi...</code></div>

    <h3>External Secrets Operator</h3>
    <p>Sync secrets from external providers (Vault, AWS Secrets Manager):</p>

    <div class="code-block"><code>apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: db-credentials
spec:
  refreshInterval: 1h
  secretStoreRef:
    kind: ClusterSecretStore
    name: vault-backend
  target:
    name: db-secret
    creationPolicy: Owner
  data:
    - secretKey: username
      remoteRef:
        key: secret/data/myapp/db
        property: username
    - secretKey: password
      remoteRef:
        key: secret/data/myapp/db
        property: password</code></div>

    <h3>SOPS with Age/GPG</h3>
    <p>Encrypt specific values within YAML files:</p>

    <div class="code-block"><code># .sops.yaml
creation_rules:
  - path_regex: .*secrets.*\.yaml$
    encrypted_regex: ^(data|stringData)$
    age: age1...

# secrets.yaml (encrypted in Git)
apiVersion: v1
kind: Secret
metadata:
  name: mysecret
stringData:
  password: ENC[AES256_GCM,data:...,type:str]
sops:
  age:
    - recipient: age1...</code></div>

    <h2 id="rbac-multitenancy">7. RBAC and Multi-Tenancy</h2>

    <h3>AppProjects for Isolation</h3>
    <p>Use AppProjects to isolate teams:</p>

    <div class="code-block"><code>apiVersion: argoproj.io/v1alpha1
kind: AppProject
metadata:
  name: team-alpha
  namespace: argocd
spec:
  description: Team Alpha's applications
  sourceRepos:
    - 'https://github.com/org/team-alpha-*'
  destinations:
    - namespace: 'team-alpha-*'
      server: https://kubernetes.default.svc
    - namespace: 'team-alpha-*'
      server: https://prod-cluster.example.com
  clusterResourceWhitelist:
    - group: ''
      kind: Namespace
  namespaceResourceBlacklist:
    - group: ''
      kind: ResourceQuota
    - group: ''
      kind: LimitRange
  roles:
    - name: developer
      description: Team Alpha developers
      policies:
        - p, proj:team-alpha:developer, applications, get, team-alpha/*, allow
        - p, proj:team-alpha:developer, applications, sync, team-alpha/*, allow
      groups:
        - team-alpha-devs</code></div>

    <h3>SSO Integration with Dex</h3>

    <div class="code-block"><code>apiVersion: v1
kind: ConfigMap
metadata:
  name: argocd-cm
  namespace: argocd
data:
  url: https://argocd.example.com
  dex.config: |
    connectors:
      - type: oidc
        id: okta
        name: Okta
        config:
          issuer: https://company.okta.com
          clientID: $oidc.clientId
          clientSecret: $oidc.clientSecret
          requestedScopes:
            - openid
            - profile
            - email
            - groups</code></div>

    <h2 id="sync-strategies">8. Sync Strategies and Hooks</h2>

    <h3>Sync Waves</h3>
    <p>Control the order of resource creation:</p>

    <div class="code-block"><code># Namespace first (wave -1)
apiVersion: v1
kind: Namespace
metadata:
  name: myapp
  annotations:
    argocd.argoproj.io/sync-wave: "-1"

# ConfigMaps second (wave 0)
apiVersion: v1
kind: ConfigMap
metadata:
  name: myapp-config
  annotations:
    argocd.argoproj.io/sync-wave: "0"

# Deployment last (wave 1)
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
  annotations:
    argocd.argoproj.io/sync-wave: "1"</code></div>

    <h3>Resource Hooks</h3>
    <p>Run jobs at specific phases:</p>

    <div class="code-block"><code>apiVersion: batch/v1
kind: Job
metadata:
  name: db-migration
  annotations:
    argocd.argoproj.io/hook: PreSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded
spec:
  template:
    spec:
      containers:
        - name: migrate
          image: myapp:v2
          command: ["./migrate.sh"]
      restartPolicy: Never
  backoffLimit: 3</code></div>

    <h2 id="day2-operations">10. Day 2 Operations at Scale</h2>

    <p>
      Setup is easy. Operating ArgoCD at scale across multiple environments (Dev/Staging/Prod) is where
      the real engineering challenges emerge. This section covers what the tutorials don't tell you.
    </p>

    <h3>Scaling ArgoCD for Multi-Environment Deployments</h3>

    <p>At scale, ArgoCD's default configuration becomes a bottleneck. Here's how we scaled:</p>

    <h4>Application Controller Sharding</h4>
    <p>
      The application controller watches all applications by default. As your app count grows, reconciliation
      can become slow. Enable sharding to distribute the load:
    </p>

    <div class="code-block"><code># argocd-cm ConfigMap
data:
  controller.sharding.algorithm: legacy  # or "round-robin"
  controller.sharding.replicas: "3"

# Deploy multiple controller replicas
apiVersion: apps/v1
kind: Deployment
metadata:
  name: argocd-application-controller
spec:
  replicas: 3  # Match sharding.replicas</code></div>

    <h4>Repo Server Horizontal Scaling</h4>
    <p>
      The repo server generates manifests and is CPU/memory intensive. Scale it horizontally
      and tune the parallelism:
    </p>

    <div class="code-block"><code>apiVersion: apps/v1
kind: Deployment
metadata:
  name: argocd-repo-server
spec:
  replicas: 5  # Scale based on app count
  template:
    spec:
      containers:
        - name: argocd-repo-server
          resources:
            requests:
              cpu: "1"
              memory: "2Gi"
            limits:
              cpu: "2"
              memory: "4Gi"
          env:
            - name: ARGOCD_EXEC_TIMEOUT
              value: "180s"  # Default 90s is too short at scale
            - name: ARGOCD_REPO_SERVER_PARALLELISM_LIMIT
              value: "50"    # Default is 0 (unlimited)</code></div>

    <div class="lesson-learned">
      <h4>Lesson Learned: Rate Limiting Considerations</h4>
      <p>
        With many applications polling Git frequently, you can hit API rate limits
        causing intermittent 403 errors. Solutions include: (1) webhook-based sync instead of polling,
        (2) increased refresh interval to 5 minutes, and (3) proper caching. This can result in a
        <strong>significant reduction in Git API calls</strong>.
      </p>
    </div>

    <h3>Disaster Recovery for ArgoCD Itself</h3>

    <p>
      Your GitOps tool is a critical dependency. What happens when the ArgoCD namespace is accidentally
      deleted or the cluster hosting ArgoCD dies?
    </p>

    <h4>Declarative ArgoCD (App-of-Apps)</h4>
    <p>Manage ArgoCD itself with GitOps. Store ArgoCD's configuration in Git:</p>

    <div class="code-block"><code># argocd-apps/argocd/kustomization.yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization
namespace: argocd
resources:
  - https://raw.githubusercontent.com/argoproj/argo-cd/v2.9.3/manifests/install.yaml
  - projects/
  - applications/
patches:
  - path: patches/argocd-cm.yaml
  - path: patches/argocd-rbac-cm.yaml</code></div>

    <h4>Backup Strategy</h4>
    <div class="code-block"><code># Automated daily backup via CronJob
apiVersion: batch/v1
kind: CronJob
metadata:
  name: argocd-backup
  namespace: argocd
spec:
  schedule: "0 2 * * *"  # Daily at 2 AM
  jobTemplate:
    spec:
      template:
        spec:
          containers:
            - name: backup
              image: bitnami/kubectl:latest
              command:
                - /bin/sh
                - -c
                - |
                  kubectl get applications,appprojects -n argocd -o yaml | \
                  aws s3 cp - s3://my-backups/argocd/$(date +%Y-%m-%d).yaml
          restartPolicy: OnFailure</code></div>

    <h4>Recovery Procedure</h4>
    <ol>
      <li>Reinstall ArgoCD from your Git repo (not manual kubectl commands)</li>
      <li>Restore AppProjects first (RBAC dependencies)</li>
      <li>Restore Applications</li>
      <li>ArgoCD will automatically sync everything back to desired state</li>
    </ol>

    <div class="real-world">
      <h4>From My Experience</h4>
      <p>
        During a cluster migration, we tested our DR procedure by destroying the ArgoCD namespace.
        Full recovery took <strong>12 minutes</strong>: 2 minutes to reinstall ArgoCD, 10 minutes for
        all 400 applications to reach healthy state. The key: everything was in Git, so ArgoCD
        just had to apply what it found.
      </p>
    </div>

    <h3>GitOps Horror Stories (And How to Prevent Them)</h3>

    <table>
      <thead>
        <tr>
          <th>Horror Story</th>
          <th>What Happens</th>
          <th>Prevention</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>Force-push to main</strong></td>
          <td>ArgoCD syncs all apps to wrong state</td>
          <td>Branch protection + signed commits</td>
        </tr>
        <tr>
          <td><strong>Git provider outage</strong></td>
          <td>ArgoCD can't refresh, shows stale state</td>
          <td>Aggressive manifest caching + graceful degradation alerts</td>
        </tr>
        <tr>
          <td><strong>Runaway sync loop</strong></td>
          <td>App continuously syncs, never healthy</td>
          <td>ignoreDifferences for volatile fields + sync retry limits</td>
        </tr>
        <tr>
          <td><strong>Namespace deletion</strong></td>
          <td>ArgoCD deletes all resources (cascade)</td>
          <td>finalizers + resource deletion protection</td>
        </tr>
        <tr>
          <td><strong>Secret in plain Git</strong></td>
          <td>Credentials exposed in history forever</td>
          <td>Pre-commit hooks + git-secrets + External Secrets</td>
        </tr>
      </tbody>
    </table>

    <div class="lesson-learned">
      <h4>War Story: The Great Sync Storm of 2024</h4>
      <p>
        A developer updated a shared ConfigMap that 200 apps depended on. ArgoCD detected drift in all
        200 apps and tried to sync them simultaneously, overwhelming the K8s API server. We added
        <strong>application-level sync windows</strong> to stagger syncs and <strong>rate limits</strong>
        on concurrent syncs. Now, max 20 apps sync concurrently.
      </p>
    </div>

    <h2 id="rollback-recovery">11. Rollback and Disaster Recovery</h2>

    <h3>Quick Rollback</h3>

    <div class="code-block"><code># CLI rollback
argocd app rollback myapp --revision 5

# Or simply revert the Git commit
git revert HEAD
git push origin main

# ArgoCD will automatically sync to the reverted state</code></div>

    <h3>Backup ArgoCD</h3>

    <div class="code-block"><code># Export all ArgoCD resources
argocd admin export > argocd-backup.yaml

# Backup specific applications
kubectl get applications -n argocd -o yaml > apps-backup.yaml
kubectl get appprojects -n argocd -o yaml > projects-backup.yaml

# Restore
kubectl apply -f argocd-backup.yaml</code></div>

    <h2 id="monitoring">10. Monitoring and Alerting</h2>

    <h3>Prometheus Metrics</h3>
    <p>ArgoCD exposes metrics at /metrics. Key metrics to monitor:</p>

    <table>
      <tr>
        <th>Metric</th>
        <th>Description</th>
        <th>Alert Threshold</th>
      </tr>
      <tr>
        <td>argocd_app_info</td>
        <td>Application health/sync status</td>
        <td>health_status != "Healthy"</td>
      </tr>
      <tr>
        <td>argocd_app_sync_total</td>
        <td>Sync operations count</td>
        <td>Failures > 5/hour</td>
      </tr>
      <tr>
        <td>argocd_cluster_api_resource_objects</td>
        <td>Cluster resource count</td>
        <td>> 10000</td>
      </tr>
      <tr>
        <td>argocd_git_request_duration</td>
        <td>Git operation latency</td>
        <td>> 30s</td>
      </tr>
    </table>

    <h3>Notification Configuration</h3>

    <div class="code-block"><code>apiVersion: v1
kind: ConfigMap
metadata:
  name: argocd-notifications-cm
  namespace: argocd
data:
  service.slack: |
    token: $slack-token
  template.app-sync-failed: |
    message: |
      Application {{.app.metadata.name}} sync failed!
      Revision: {{.app.status.sync.revision}}
      Error: {{.app.status.operationState.message}}
  trigger.on-sync-failed: |
    - when: app.status.operationState.phase in ['Error', 'Failed']
      send: [app-sync-failed]</code></div>

    <h2 id="anti-patterns">13. Anti-Patterns to Avoid</h2>

    <p>
      These are the mistakes I've seen (and made) that distinguish junior GitOps implementations from
      production-grade platforms. Learn from others' scars.
    </p>

    <h3>The Good, The Bad, and The Ugly</h3>

    <table>
      <thead>
        <tr>
          <th>Anti-Pattern</th>
          <th>Why It's Tempting</th>
          <th>Why It's Dangerous</th>
          <th>Better Approach</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>Sealed Secrets for everything</strong></td>
          <td>Simple, keeps secrets in Git</td>
          <td>Key rotation requires re-sealing all secrets; blast radius is entire cluster</td>
          <td>External Secrets Operator + AWS Secrets Manager/Vault</td>
        </tr>
        <tr>
          <td><strong>Sync every 30 seconds</strong></td>
          <td>"Real-time" feels responsive</td>
          <td>DDoS your Git provider; wastes compute; no value at high frequency</td>
          <td>3-5 minute intervals + webhook triggers for instant sync</td>
        </tr>
        <tr>
          <td><strong>Auto-sync production</strong></td>
          <td>Faster deployments</td>
          <td>No human gate; bad merge ‚Üí immediate outage</td>
          <td>Manual sync + required approvals in PR</td>
        </tr>
        <tr>
          <td><strong>Single monolithic repo</strong></td>
          <td>Easier to manage initially</td>
          <td>PR bottlenecks; slow clones; permission complexity</td>
          <td>App-of-Apps pattern with multiple repos</td>
        </tr>
        <tr>
          <td><strong>No sync windows</strong></td>
          <td>Deploy anytime</td>
          <td>3 AM deploys; Friday evening surprises</td>
          <td>Sync windows blocking off-hours for prod</td>
        </tr>
        <tr>
          <td><strong>Ignoring resource hooks</strong></td>
          <td>Just let everything sync</td>
          <td>Database migrations race with app deployments</td>
          <td>PreSync hooks for migrations; PostSync for cleanup</td>
        </tr>
      </tbody>
    </table>

    <div class="lesson-learned">
      <h4>The Sealed Secrets Trap</h4>
      <p>
        We started with Sealed Secrets because it was simple. Then we needed to rotate a database
        password. Because we had 50+ sealed secrets referencing it, we had to: (1) generate new sealed
        secrets for all 50, (2) commit them all, (3) pray nothing broke during the rollout. Migrating
        to External Secrets Operator took 2 weeks but reduced secret rotation from hours to seconds.
        <strong>Choose based on Day 100 operations, not Day 1 setup.</strong>
      </p>
    </div>

    <h3>Code Smell: You're Doing GitOps Wrong If...</h3>

    <ul>
      <li>‚ùå Developers SSH into pods to "fix" things instead of updating Git</li>
      <li>‚ùå You have kubectl scripts running in CI "just for this one deployment"</li>
      <li>‚ùå ArgoCD shows "OutOfSync" for more than 10% of apps at any time</li>
      <li>‚ùå You're manually running <code>argocd sync</code> as part of release process</li>
      <li>‚ùå Rollback requires more than <code>git revert && git push</code></li>
      <li>‚ùå You don't know which commit is running in production</li>
    </ul>

    <h2 id="edge-cases">14. Edge Cases and Troubleshooting</h2>

    <div class="edge-case">
      <h4>‚ö†Ô∏è Application Stuck in "Progressing"</h4>
      <p>Common causes and solutions:</p>
      <ul>
        <li><strong>Image pull failures:</strong> Check imagePullSecrets and registry access</li>
        <li><strong>Resource limits:</strong> Pod can't be scheduled due to insufficient resources</li>
        <li><strong>PVC pending:</strong> StorageClass doesn't exist or no capacity</li>
        <li><strong>Readiness probe failing:</strong> Application not responding on health endpoint</li>
      </ul>
      <div class="code-block"><code>kubectl describe pod &lt;pod-name&gt; -n &lt;namespace&gt;
kubectl logs &lt;pod-name&gt; -n &lt;namespace&gt;
argocd app get &lt;app-name&gt; --show-operation</code></div>
    </div>

    <div class="edge-case">
      <h4>‚ö†Ô∏è Sync Loops / Continuous Reconciliation</h4>
      <p>ArgoCD keeps syncing even when nothing changed:</p>
      <ul>
        <li>Resource has fields that are constantly mutated (e.g., annotations by other controllers)</li>
        <li>Solution: Use ignoreDifferences in Application spec</li>
      </ul>
      <div class="code-block"><code>spec:
  ignoreDifferences:
    - group: apps
      kind: Deployment
      jsonPointers:
        - /spec/replicas  # Ignore HPA changes
    - group: ""
      kind: Service
      jqPathExpressions:
        - .metadata.annotations["field.cattle.io/publicEndpoints"]</code></div>
    </div>

    <div class="edge-case">
      <h4>‚ö†Ô∏è Out of Sync with Helm Hooks</h4>
      <p>Helm hooks can cause permanent OutOfSync status:</p>
      <div class="code-block"><code>spec:
  source:
    helm:
      skipCrds: true
  syncPolicy:
    syncOptions:
      - RespectIgnoreDifferences=true
      - ApplyOutOfSyncOnly=true</code></div>
    </div>

    <h2 id="security-hardening">12. Security Hardening</h2>

    <h3>Network Policies</h3>

    <div class="code-block"><code>apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: argocd-server
  namespace: argocd
spec:
  podSelector:
    matchLabels:
      app.kubernetes.io/name: argocd-server
  policyTypes:
    - Ingress
    - Egress
  ingress:
    - from:
        - namespaceSelector:
            matchLabels:
              name: ingress-nginx
      ports:
        - protocol: TCP
          port: 8080
  egress:
    - to:
        - podSelector:
            matchLabels:
              app.kubernetes.io/name: argocd-repo-server
      ports:
        - protocol: TCP
          port: 8081</code></div>

    <h3>Audit Logging</h3>

    <div class="code-block"><code>apiVersion: v1
kind: ConfigMap
metadata:
  name: argocd-cm
data:
  server.audit.enabled: "true"
  server.audit.log.format: json</code></div>

    <h2>Key Takeaways</h2>

    <ol>
      <li><strong>Git is the source of truth:</strong> Every change must go through Git for auditability</li>
      <li><strong>Start simple:</strong> Begin with basic sync, add complexity (Rollouts, hooks) as needed</li>
      <li><strong>Secure secrets:</strong> Never commit plaintext secrets; use Sealed Secrets or External Secrets
      </li>
      <li><strong>Use AppProjects:</strong> Isolate teams with proper RBAC boundaries</li>
      <li><strong>Monitor aggressively:</strong> Set up alerts for sync failures and application health</li>
      <li><strong>Test rollbacks:</strong> Regularly practice rollback procedures in non-prod environments</li>
    </ol>

    <div class="footer">
      <p>Ready to implement GitOps in your organization?</p>
      <a href="/portfolio/#contact" class="cta">Let's Discuss ‚Üí</a>
    </div>
  </article>
  <script src="article-interactive.js"></script>
</body>

</html>